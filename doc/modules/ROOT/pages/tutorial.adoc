[#tutorial]

= Tutorial (advanced usage)

:idprefix: tutorial_

[#tutorial_manip]
== Manipulation of non-managed memory

In this first example, we are going to use memory that is not managed by the library and manipulate the elements.
This is to show that the library can operate on raw memory that is already available through other libraries or part of the code;
in the next section instead we will see an example of arrays owned by the library.
We can create a static C-array of ``double``s, and refer to it via a bidimensional array `multi::array_ref<double, 2>`.

(This tutorial can be followed https://godbolt.org/z/4zWTPcoK6[online].)

[source,cpp]
----
#include <boost/multi/array_ref.hpp>  // for unmanaged memory

namespace multi = boost::multi;

int main() {
	double d_data[20] = {
		150.0, 16.0, 17.0, 18.0, 19.0,
		 30.0,  1.0,  2.0,  3.0,  4.0,
		100.0, 11.0, 12.0, 13.0, 14.0,
		 50.0,  6.0,  7.0,  8.0,  9.0
	};  // block of 20 elements ...
	multi::array_ref<double, 2> d2D_ref({4, 5}, &d_data[0]);  // .. interpreted as a 4 by 5 array
	...
----

Because this array is not controled by the library, this type of object is refered to as an array-reference.

Next, as an illustration, we print the elements in a way that corresponds to the logical arrangement.
(Also generic printing can be done in other ways described in the reference section.)
To do that, first, we extract the extensions (the 2-dimensional range of valid indexes) of the array,
then we decompose it as the cartesian product of two 1-dimensional ranges of integer indices.

[source,cpp]
----
#include <iostream>  // for print
	...
	auto [is, js] = d2D_ref.extensions();
	for(auto i : is) {
		for(auto j : js) {
			std::cout<< d2D_ref[i][j] <<' ';
		}
		std::cout <<'\n';
	}
----

This will output:

> ```
> 150 16 17 18 19
> 30 1 2 3 4
> 100 11 12 13 14
> 50 6 7 8 9
> ```

This is just an example to demonstrate the use of loops;
the library provide iterator-based access, which allows it to interface with algorithms and implement new ones.

It is sometimes said (by Sean Parent) that the whole of STL algorithms can be seen as intermediate pieces to implement `std::stable_sort`.
Presumably, if one can sort over a range, one can perform any other standard algorithm.

[source,cpp]
----
#include <algorithm>  // for sort
	...
	std::stable_sort( d2D_ref.begin(), d2D_ref.end() );
----

If we print the result again, we get:

> ```
> 30 1 2 3 4
> 50 6 7 8 9
> 100 11 12 13 14
> 150 16 17 18 19
> ```

The array has been changed to be in row-based lexicographical order.
Since the sorted array is a reference to the original data, the original C-array has changed.

(Note that `std::sort` cannot be applied directly to a multidimensional C-array or to other libraries, such as Boost.MultiArray.
The library here are supports all STL algorithms directly.)

If we want to order the matrix on a per-column basis, we need to "view" the matrix as a range of columns.
This is done in the bidimensional case, by accessing the matrix as a range of columns:

[source,cpp]
----
	...
	std::stable_sort( d2D_ref.rotated().begin(), d2D_ref.rotated().end() );
}
----

The `rotate` operation rotates indices, providing a new logical view of the original array without modifying it.

In this case, the original array will be transformed by sorting the matrix into:

> ```
> 1 2 3 4 30
> 6 7 8 9 50
> 11 12 13 14 100
> 16 17 18 19 150
> ```

By combining index rotations and transpositions, an array of dimension `D` can be viewed simultaneously as `D!` (D-factorial) different ranges of different "transpositions" (rotation/permutation of indices.)

Of course many other standard algorithms work with arrays at the top level dimension, or a the element level dimension.
For example, after sorting, all the permutations of rows can be generated by `std::next_permutation(A.begin(), A.end())` (see https://godbolt.org/z/h7rjf8ojb[here])

[#tutorial_init]
== Initialization

Libraries array objects (`multi::array`) own the elements they contain and can be resized later;
because of their semantic properties they are called array-values.
An `array` is initialized by specifying the index extensions and, optionally, a default value).

[source,cpp]
----
#include <boost/multi/array.hpp>  // for array value containers (owning memory)

auto A1 = multi::array<int, 1>({3}      , 11);  // {11, 11, 11}

auto A2 = multi::array<int, 2>({2, 3}   , 22);  // { {22, 22, 22}, {22, 22, 22} }

auto A3 = multi::array<int, 3>({3, 2, 2}, 33);  // { { { 33, ...}, { ... }, ... } }
----
... or alternatively from a rectangular list.

[source,cpp]
----
multi::array<int, 1> A1 = {1, 2, 3};
assert( A1.elements().size() == 3 );  // or A1.num_elements()

multi::array<int, 2> A2 = {
	{ 1, 2, 3},
	{ 4, 5, 6}
};

assert( A2.elements().size() == 2*3);

multi::array<int, 3> const A3 = {
	{{ 12,   0}, { 24, 10}},
	{{112,  30}, {344, 40}},
	{{152, 990}, {324, 20}}
};

assert( A3.elements().size() == 3 * 2 * 2 );
----

Finally, initialization of array variables can determine both the element type and dimensionality (Class Template Argument Deduction) from the right-hand-side.
This is particularly useful when using direct initialization or initialization from subarrays.

[source,cpp]
----
multi::array A1D = {1, 2, 3};  // deduced as array<int, 1>
multi::array A2D = {           // deduced as array<int, 2>
	{1, 2, 3},
	{3, 4, 5}
};

multi::array row = A2D[1];     // deduced as array<int, 1>
----

In all cases, constness (`const` declaration) is honored in the expected way.

Unlike `array` objects, `array_ref` objects do not own the elements they contain, and they are initialized from a preexisting contiguous range, the index extensions should be compatible with the total number of elements.

[source,cpp]
----
double* dp = new double[12];
multi::array_ref<double, 2> A({3, 4}, dp);
multi::array_ref<double, 2> B({2, 6}, dp);
...
delete[] dp;
----

Array references do not own memory and, just as language references, can not be rebinded (i.e. resized or "reseated") to refer to a different memory location.
Since `array_ref` is an array reference, it can "dangle" if the original memory is deallocated.

[#tutorial_copy_assign]
== Copy, and assigment (, and aliasing)

The library offers value semantics for the `multi::array<T, D>` family of classes.
Constructing or assigning from an existing array generates a copy of the original object, independent of the original one but equal in value.

[source,cpp]
----
auto B2 = A2;  // same as multi::array<double, 2> B2 = A2; (A2 is defined above)

assert(  B2       ==  A2       );  // copies have the same element values (and also the same shape)
assert(  B2[0][0] ==  A2[0][0] )
assert( &B2[0][0] != &A2[0][0] );  // but they are independent
----

A (mutable) array can be assigned at any moment, independently of the previous state or shape (extensions).
The dimensionality must match.

[source,cpp]
----
B2 = A2;  // both have dimensionality 2
----

Sometimes it is necessary to generate copies from views or subblocks.

[source,cpp]
----
multi::array<double, 3> C2 = A2( {0, 2}, {0, 2} );
----
or equivalently,

[source,cpp]
----
auto C2 = + A2( {0, 2}, {0, 2} );
----
Note the use of the prefix `\+` (plus) as an indicator that a copy must be created (it has no arithmetic implications).
Due to a language limitation, omitting the plus symbol will create another non-independent reference view of the left-hand side, which is generally undesired.

Subarray-references can also be assigned, but only if the shapes of the left-hand side (LHS) and right-hand side (RHS) match.
Otherwise, the behavior is undefined (in debug mode, the program will fail an assertion).

[source,cpp]
----
C2( {0, 2}, {0, 2} ) = A2( {0, 2}, {0, 2} );  // both are 2x2 views of arrays, *elements* are copied
----

Using the same or overlapping arrays in the RHS and LHS of assignment produces undefined behavior in general (and the library doesn't check).
Notably, this instruction does not transpose the array but produces an undefined result:

[source,cpp]
----
A2 = A2.transposed();  // undefined result, this is an error
----

This is an instance of the problem of _data aliasing_, which describes a common situation in which a data location in memory can be accessed through different parts of an expression or function call.

This statement below, instead, does produce a transposition, at the cost of making one copy (implied by `+`) of the transposed array first and assigning (or moving) it back to the original array.

[source,cpp]
----
A2 = + A2.transposed();  // ok, (might allocate)
----

Within the confines of the library interface, this pitfall can only occur on assignment.
A generic workaround is to use the prefix `operator+`, to break "aliasing" as above.

In general, the problem of aliasing can persist when taking mutable array-references in function arguments.
The most general solution to this problem is to make copies or directly work with completely disjoint objects.
Other case-by-case solutions might be possible.
(For example, in-place transposition (as attempted above) is an active subject of research;
_optimal_ speed and memory transpositions might require specially designed libraries.)

Note that this is also different from creating a named reference:

Finally, arrays can be efficiently moved by transferring ownership of the internal data.

[source,cpp]
----
auto B2 = std::move(A2);  // A2 is empty after this
----

Subarrays do not own the data; therefore they cannot directly take advantage of this feature.
However, individual elements of a view can still be moved; this is particularly useful if the elements are expensive to copy (elements that are containers themselves for example).
A "moved" subview is simply another kind of view of the elements.

[source,cpp]
----
multi::array<std::vector<double>, 2> A({10, 10}, std::vector<double>(1000));
multi::array<std::vector<double>, 2> B({10, 10});
...
B[1] = A[2].element_moved();
----

Each of the 10 *elements* of the third row of `A` is moved into the second row of `B`.
`A[2]` still has 10 (moved-from) empty vectors.

In summary, to make a copy (enforce value semantics), use prefix `operator+`, to enforce reference semantics (avoid copies) use `auto&&` declarations:

* Always use `auto&& ref = x;` (or `auto const& cref = x;`) if you need the reference semantics (named reference), where `x` is a subarray expression.
* Always use `auto val = + x;` (or `auto const val = + x;`) if you need value semantics, where `x` is subarray expression. (This is optimal even if `x` is a plain `multi::array`).
* Avoid `auto y = x;`, although accepted by the language, it is not clear what category or lifetime `y` has.

[#tutorial_change_size]
== Change sizes (extents)

Arrays can change their size while _preserving elements_ with the `reextent` method.

[source,cpp]
----
multi::array<int, 2> A = {
	{1, 2, 3},
	{4, 5, 6}
};

A.reextent({4, 4});

assert( A[0][0] == 1 );
----

An alternative syntax with an additional parameter, `.reextent({...}, value)`, sets _new_ (not preexisting) elements to a specific value.

The primary purpose of `reextent` is element preservation.
All calls to `reextent` allocate and deallocate memory; therefore, they are not amortized.
If element preservation is not desired, a simple assignment (move) from a new array better expresses the intention and is more efficient since it doesn't need to copy preexisting elements.

[source,cpp]
----
A = multi::array<int, 2>({4, 4});  // extensions like A.reextent({4, 4}) but elements are not preserved

A = multi::array<int, 2>({4, 4}, 99)  // for initialization with specific value 99

A = {};  // empties the array, equivalent to `A.reextent({0, 0});`.
----

Subarrays or views cannot change their size or be emptied (e.g., `A[1].rextent(+{4}+)` or `A[1].clear()` will not compile).
For the same reason, subarrays cannot be assigned from an array or another subarray of different size.

Changing the size of arrays by `reextent`, `clear`, or assignment generally invalidates existing iterators and ranges/views.

[#tutorial_iteration]
== Iteration (vs range-loops)

Historically, iteration over arrays has been done with index-based `for`-loops, where each nesting level is associated with a subdimension.
For this type of usage, the valid range of indices in all the dimensions of an array is extracted with `.extensions()`, and in the 2D case, `.extensions()` can be conveniently decomposed into two ranges, one for each dimension.

[source,cpp]
----
	multi::array<int, 2> A = {
		{1, 2, 3},
		{4, 5, 6}
	};

	auto [is, js] = A.extensions();
	for(auto i : is) {  // is == {0, 1} (range from 0 to 2, not included)
		for(auto j : js) {  // ij = {0, 1, 2} (range from 0 to 3, not included)
			A[i][j] *= 2;
		}
	}
----

Using C++'s range-based for, the elements of the 2D array can be accessed directly without intermediate indices:

[source,cpp]
----
	for(auto&& row : A) {
		for(auto&& e: row) {  // equivalent to for(auto& e: row) or for(int& e: row)
			e *= 2;
		}
	}
----

However, in some cases it is better to use the iterator-based interface.
The iterator-based interface is more convenient to express and interact with generic algorithms, which in turn can be parallelized and less prone to index errors (such as off-by-one, and out-of-range access.)

Array (and subarray-references) provide a members `.begin()` and `.end()` that produce iterators that access the multidimensional structure through the first dimension (leftmost index).
Accessing arrays by iterators (`begin`/`end`) enables the use of many iterator-based algorithms (see the sort example above).
`begin(A)/end(A)` (or equivalently `A.begin()/A.end()`) gives iterators that are linear and random access in the leading dimension.
Since these iterators are categorized as random-access, arithmetic can be performed on them, for example `it += n;` and `++it` will advance `it` by `n` positions or by one position respectively.

As an alternative, the elements can be iterated in a flat manner, using the `.elements()` member.
This "elements" range also provides the `begin` and `end` iterators (`.elements().begin()`) and indexing, in the canonical order of the original arrays (rightmost index changes fastest).
The elements range is always random-access, but it can be also contiguous depending on the original array (`multi::array` generally give contiguous element ranges.)

Other non-leading dimensions can be obtained by "rotating" indices first.
`A.rotated().begin()/.end()` gives access to a range of subarrays in the second dimension number (the first dimension is put at the end).
(`.cbegin()/.cend()` give constant (read-only) access.)

As an example, this function allows printing arrays of arbitrary dimensionality into a linear comma-separated form.

[source,cpp]
----
void recursive_print(double const& d) { cout<<d; };  // terminating overload

template<class Array>
void recursive_print(Array const& ma) {
	cout << "{";
	if(! ma.empty()) {
		flat_print(*ma.begin());  // first element
		std::for_each(ma.begin() + 1, ma.end(), [](auto const& e) { cout<<", "; flat_print(e);});  // rest
	}
	cout << "}";
}
...
recursive_print(A);
----
> ```
> {{{1.2, 1.1}, {2.4, 1}}, {{11.2, 3}, {34.4, 4}}, {{15.2, 99}, {32.4, 2}}}
> ```

Except for those corresponding to the one-dimensional case, dereferencing iterators generally produce "proxy"-references (i.e. objects that behave in a large degree like language references).
These references can be given a name; using `auto` can be misleading since the resulting variable does not have value semantics.

[source,cpp]
----
auto row = *A.begin();  // accepted by the language but misleading, row is *not* a value independent of A
----

In my experience, however, the following usage pattern produces a more consistent idiom for generating references (still without copying elements):

[source,cpp]
----
auto&&       row0 = *A.begin() ;  // same as decltype(A)::      reference  row0 = * begin(A);
auto const& crow0 = *A.cbegin();  // same as decltype(A)::const_reference crow0 = *cbegin(A);

auto&&       row1 =               A [1];  // same as decltype(A)::      reference  row1 =               A [1];
auto const& crow1 = std::as_const(A)[1];  // same as decltype(A)::const_reference crow0 = std::as_const(A)[1];
----

The resulting object are of type `multi::subarray`, a type name that is rarely used explicity in code, thanks to the use of `auto`. 
Because of their semantics they are called subarray-references and they are documented in the library's reference section.

If a new value (array-value) is desired, these (equivalent) options express the intention more explicitly:

[source,cpp]
----
decltype(A)::value_type row =   *begin(A);  // there is a real copy of the row
                   auto row = + *begin(A);  // there is another copy, note the use of '+' (unary plus)
----

In the examples above all elements are accessed in a nested way, recursively down the dimensions.
To iterate over all the elements regardless of the multidimensional structure the following function can print all the elements.

[source,cpp]
----
template<class Array>
void flat_print(Array const& ma) {
	cout << "[";
	std::for_each(ma.elements().begin(), ma.elements().end(), [](auto&& e) { cout<< e << ", ";});
	cout << "]";
}
...
recursive_print(A);
----
> ```
> [1.2, 1.1, 2.4, 1, 11.2, 3, 34.4, 4, 15.2, 99, 32.4, 2]
> ```

This feature allows to view the array as a flat sequence using the `.elements()` range, which also has `.begin()`/`.end()` and indexing.

// == "Pointer" to subarray

// The library strongly relies on value-semantics, and it doesn't entertain the concept of "shallow" copy;
// however, it supports reference- and pointer-semantics.

// Subarrays (e.g., rows in a 2D array) are reference-like objects with a concrete address-like value that identifies them uniquely.
// These addresses, which behave like pointers, can be helpful to "mark" subviews; these markers can be copied and stored in arrays.

// ```cpp
// auto A = multi::array<double, 2>({4, 4});

// auto row2_ptr = &A[2];  // A[2] is a row of A (not an element)
// assert( row2_ptr == &*(A.begin() + 2) );
// ```

// The expression `A[2]` above is technically a C++ temporary object, and therefore it doesn't have a C++ address (taking `std::addressof` gives a compilation error).
// However, in the library's abstraction, `A[2]` references an existing part of the original array, i.e. it is a "library reference", whose "library address" can be obtained with the `&` operator.
// The case is an illustration that, in the library, operator `&` is, for subarrays, different than the `std::addressof` operator; the latter may not be defined and even not compile for some expressions.

// Comparing these markers/pointers with different provenance, i.e., originating from different arrays, is generally undefined.

[#tutorial_indexing]
== Indexing

Arrays provide random access to elements or subviews.
Many algorithms on arrays are oriented to linear algebra,
which are ubiquitously implemented in terms of multidimensional index access.

Iterator access and index access are two alternatives for accessing elements.
For example `*(begin(A) + n)` and `A[n]` are equivalent
and the range defined by the pair `begin(A), end(A)` is equivalent to `A(extension(A))` and, in turn, to `A()` (even for a multidimensional array, `D > 1`).
The syntax can be combined in arbitrary ways, for example `*begin(A[n])` is equivalent to `A[n][0]`.

[#tutorial_element_access]
== Element access and partial access

Index access mimics that of C-fixed sizes arrays. 
For example, a 2-dimensional array will access to an element by specifying two indices `A[1][2]`,
which can be used for direct write and read operations; 
while _partial_ index arguments `A[1]` generate a view 1-dimensional object (a reference).

[source,cpp]
----
A        // is a 2D array-value
A[0]     // is a 1D subarray-reference
A[0][0]  // is a an element reference
----

Transpositions are also multidimensional arrays _views_ in which the index are *logically* rearranged, for example `rotated(m)[2][3][1] == m[1][2][3]`.
(`rotated`/`unrotated` refers to the fact that the logical _indices_ are rotated to the left/right.)

As an illustration of an algorithm based on index access (as opposed to iterators),
this example code implements Gauss Jordan Elimination without pivoting:

[source,cpp]
----
template<class Matrix, class Vector>
auto gj_solve(Matrix&& A, Vector&& y) -> Vector&& {
	std::ptrdiff_t Asize = size(A);
	for(std::ptrdiff_t r = 0; r != Asize; ++r) {
		auto&& Ar = A[r];
		auto&& Arr = Ar[r];
		for(std::ptrdiff_t c = r + 1; c != Asize; ++c) {Ar[c] /= Arr;}
		auto const yr = (y[r] /= Arr);
		for(std::ptrdiff_t r2 = r + 1; r2 != Asize; ++r2) {
			auto&& Ar2 = A[r2];
			auto const& Ar2r = Ar2[r];  // auto&& Ar = A[r];
			for(std::ptrdiff_t c = r + 1; c != Asize; ++c) {Ar2[c] -= Ar2r*Ar[c];}
			y[r2] -= Ar2r*yr;
		}
	}
	for(std::ptrdiff_t r = Asize - 1; r > 0; --r) {
		auto const& yr = y[r];
		for(std::ptrdiff_t r2 = r-1; r2 >=0; --r2) {y[r2] -= yr*A[r2][r];}
	}
	return std::forward<Vector>(y);
}
----

This function can be applied to a `multi::array` container:

[source,cpp]
----
multi::array<double, 2> A = {{-3.0, 2.0, -4.0},{0.0, 1.0, 2.0},{2.0, 4.0, 5.0}};
multi::array<double, 1> y = {12.0, 5.0, 2.0};  // (M); assert(y.size() == M); iota(y.begin(), y.end(), 3.1);
gj_solve(A, y);
----

and also to a combination of `MultiArrayView`-type objects (including standard vectors):

[source,cpp]
----
auto A = multi::array<double, 2>({6000, 7000}); std::iota(A.elements().begin(), A.elements().end(), 0.1);
std::vector<double> y(3000); std::iota(y.begin(), y.end(), 0.2);  // could be also a multi::array<double, 1> y({3000});
gj_solve(A({1000, 4000}, {0, 3000}), y);
----

[#tutorial_slices_and_strides]
== Slices and strides

Given an array, a slice in the first dimension can be taken with the `sliced` function. 
`sliced` takes two arguments, the first index of the slice and the last index (not included) of the slice. For example,

[source,cpp]
----
auto A = multi::array<double, 2>({4, 5});  // A is a value
using std::get;  // needed in C++17
assert( get<0>(A.sizes()) == 4 );
assert( get<1>(A.sizes()) == 5 );

auto&& A_sliced = A.sliced(1, 3); // {{d2D[1], d2D[2]}}
using std::get;  // needed in C++17
assert( get<0>(A_sliced.sizes()) == 2 );
assert( get<1>(A_sliced.sizes()) == 5 );
----

The number of rows in the sliced matrix is 2 because we took only two rows, row 1 and row 2 (row 3 is excluded).

In the same way a strided view of the original array can be taken with the `strided` function.

[source,cpp]
----
auto&& d2D_strided = d2D.strided(2); // {{ d2D[0], d2D[1] }};
assert( d2D_strided.size(0) == 2 and d2D_strided.size(1) == 5 );
----

In this case the number of rows is 2 because, out of the 4 original rows we took one every two.

Operations can be combined in a single line:

[source,cpp]
----
auto&& d2D_slicedstrided = d2D.sliced(1, 3).strided(2); // {{ d2D[1] }};
assert( std::get<0>(d2D_slicedstrided.sizes()) == 1 and std::get<1>(d2D_slicedstrided.sizes()) == 5 );
----

For convenience, `A.sliced(a, b, c)` is the same as `A.sliced(a, b).strided(c)`.

By combining `rotated`, `sliced` and `strided` one can take sub arrays at any dimension index.
For example in a two-dimensional array one can take a subset of columns by defining.

[source,cpp]
----
auto&& subA = A.rotated().sliced(1, 3).strided(2).unrotated();
----

Other notations are available, for example this is equivalent to `A(multi::_ , {1, 3, /*every*/2})` or `~(~A)({1, 3, 2})`.
The `rotated/strided/sliced/rotated` and combinations of them provides the most control over the subview operations.

Blocks (slices) in multidimensions can be obtained by pure index notation using parentheses `()` (`.operator()`):

[source,cpp]
----
auto        A = multi::array<double, 2>({6, 7});  // 2D value array

auto&&      A_block1 = A({1, 4}, {2, 4});  // 2D subarray-reference (modifiable elements)
auto const& A_block2 = A({1, 4}, {2, 4});  // 2D subarray-reference (non-modifiable elements)

auto        A_block3 = A({1, 4}, {2, 4});  // works but it can be confusing, use `auto&&` instead
----

Sometimes copies are necessary, specifically from a subarray block, this can be done by constructing a new array-value. 
Their type can be deduced by using `auto` and the `decay` member, which in turn is equivalent to the prefix `+` operator.

```cpp
multi::array<double, 2> block_value_1 =   A({1, 4}, {2, 4})        ;
auto                    block_value_2 =   A({1, 4}, {2, 4}).decay();
auto                    block_value_3 = + A({1, 4}, {2, 4})        ;
```

Any parenthesis argument can be either a range (with or without stride) or an index. 
Range argument can be substituted by `multi::all` to obtain the whole range.

[#tutorial_conversions]
== Conversions

Conversion between arrays of distinct types is possible if the underlying elements allow it.
The result is as if elements are converted one by one;
array sizes (extensions) are preserved.
Allowed conversions can be implicit or explicit and reflect the behavior of the element types.

Here we use numerical types to illustrate conversion rules, but the rules apply to all posible element types.

[source,cpp]
----
// implicit conversions from real to complex is allowed ...
             double     d = 5.0;                  std::complex<double>     z = d;
// ... therefore it is also allowed from array of reals to arrays of complex
multi::array<double, 2> D({10, 10}); multi::array<std::complex<double>, 2> Z = D;
// implicit (or explicit) conversions from the other way (real to complex) are disallowed (compilation error)
// multi::array<double, 2> D = Z;  // or D{Z};
----

Another case is illustrated by `std::complex<float>` and `std::complex<double>`; 
in one direction, the conversion can be implicit, while in the other, it can only be explicit.
This behavior is reflected in the corresponding arrays:

[source,cpp]
----
multi::array<std::complex<float>>  C;
multi::array<std::complex<double>> Z = C;  // implicit conversion ok
multi::array<std::complex<float>>  C2{Z};  // explicit conversion is allowed
// multi::array<std::complex<float>>  C3 = Z;  // implicit conversion is disallowed (compilation error)
----

Implicit conversions are generally considered harmful, but inconsistent conversions are worst; therefore, the library allows them when appropriate.
The main drawback of implicit conversions in this context is that they might incur unexpected (e.g. costly) data conversions when passing arguments to functions.

[source,cpp]
----
void fun(multi::array<std::complex<double>> Z) { ... };
...
multi::array<double, 2> D({10, 10});
fun(D);  // real elements are converted to complex silently here
----
In many instances, specially in generic code, it might still be a desirable behavior.

To prevent implicit conversions, use element types with no implicit conversions when possible.

Finally, arrays of unrelated element types are prevented from producing direct conversions, resulting in compilation errors.
Element-wise transformations can be used instead.
For example, to convert an array of integers to an array of text strings:

[source,cpp]
----
	multi::array<int, 2> const A = {{1, 2}, {3, 4}};

	auto to_string = [](int e) { return std::to_string(e); };
	multi::array<std::string, 2> B = A.element_transformed(to_string);  // or `auto B = + ...`
	assert( B[1][1] == "4" );
----
link:https://godbolt.org/z/vP6nPY539[(live)]


[#tutorial_uninit_v_init]
== Uninitialized vs. initialized elements

If available, the library can take advantage of trivial initialization for element types that specifically support it.

Primitive types or some user-defined are defined in such a way that their construction does nothing, not even set values.
When used in the stack, these types can be declared with no initialization (e.g., `double x;`),
in which case their initial value is not well-defined or the state is called "partially-formed";
or they can be declared with initialization (e.g., `double x{};`, same as `double x = 0.0;`).
When these types are used as array elements, (e.g. `multi::array<T, D>`),
the library does not initialize individual elements unless specified.

For example, after this construction of the array, the values of the six elements of this array are unspecified (partially-formed).

[source,cpp]
----
auto A2 = multi::array<int, 2>({2, 3});  // A2 elements have unspecified value
----

No behavior of the program should depend on these values.
(Fortunately, address sanitizers and memory checkers can detect use of uninitialized values, for example Valgrind diagnoses "Uninitialized Memory Read".)
This design is a slight departure from the STL's design, which https://lemire.me/blog/2012/06/20/do-not-waste-time-with-stl-vectors/[eagerly initializes elements in containers].

If trivial construction is unavailable, the library uses the default initialization.

[source,cpp]
----
auto A2 = multi::array<std::string, 2>({2, 3});  // A2 elements have specified value: empty std::string{}
----

For types that afford this partially formed states, elements can be later specified via assignment or assigning algorithms (e.g., copy or transform destination).

Initialization can be enforced by passing a single value argument after the extensions.

[source,cpp]
----
auto A2 = multi::array<int, 2>({2, 3}, 0);  // generically multi::array<T, 2>({2, 3}, T{}); or multi::array<T, 2>({2, 3}, {})
----

This design is particularly advantageous for *numeric* types for which external low-level libraries can fill values.
(or when data sits in GPUs, where the initialization step would require an expensive kernel launch and subsequent synchronization).

Unfortunately, regarding the numeric types, STL's `std::complex<double>` was standardized as not-trivially constructible.
A workaround built-in in this library is available by forcing a particular flag on the client code in global scope, for example, immediately after including the library:

[source,cpp]
----
#include<multi/array.hpp>

template<> inline constexpr
bool multi::force_element_trivial_default_construction<std::complex<double>> = true;  // should be defined as early as possible
----

With this line, `std::complex<double>` elements inside arrays will be left uninitialized unless a value is specified.
The rule will only apply to this library's containers (`multi::array`, etc), and not to other containers (such as `std::vector`) or individual `std::complex` variables.

Finally, the library offers a tag to explicitly state the intention of having uninitialized elements: `multi::arrray<int, 2> A2({2, 3}, multi::uninitialized_elements)`.
This syntax will compile only if elements are trivially-default constructible; 
therefore and as an example `multi::arrray<std::string, 2> A2({2, 3}, multi::uninitialized_elements)` will not compile because `std::string` does not have a trivial constructor.

== Const-correctness

Const-correctness refers to the property of a program to disallow mutation of certain objects when it is undesired or logically incorrect.
Honoring the const-ness declaration is fundamental not only to avoid bugs and typos but also for thread safety and generic programming.
The library goes to great lengths to ensure const-correctness for the whole or parts of any object.

Arrays are resizable, and their elements can be mutated unless declared constant (using the keyword `const`).

A reference array or subarray is never resizable, but its elements are mutable if not declared `const`.
The design ensures that the const-ness of references and values propagates to subarrays (views) and, ultimately, their elements.

[source,cpp]
----
template<class Array1D>
void print(Array1D const& coll) {
//  *coll.begin() = 99;  // doesn't compile, "assignment of read-only location"

	for(auto const& e : coll) {std::cout<< e <<", ";}
	std::cout << std::endl;
}

int main() {
	multi::array<int, 1> const coll1 = {0, 8, 15, 47, 11, 42};

	print( coll1 );  // prints "0, 8, 15, 47, 11, 42"
	print( coll1({0, 3}) );  // prints "0, 8, 15"
}
----

As a general rule for passing generic arrays as arguments, pass them as `Array const&` (in the context of `template<class Array>`);
unless mutation is expected, in which case take arguments as `Array&&` (note the double ampersand, i.e., universal/forwarding reference).
Analogously, subarrays can be locally *named* into "constant language references" using `auto const&` and, if mutation is desired, `auto&&` should be used.
Regular references `Array&` or `auto&` in general do not have the expected behavior for views.

[source,cpp]
----
template<class Array1D>
void fill_99(Array1D&& coll) {
	for(auto& e : coll) { e = 99; }
}

int main() {
	multi::array<int, 1> coll1 = {0, 8, 15, 47, 11, 42};

	fill_99( coll1 );
	fill_99( coll1({0, 3}) );

	auto&& coll1_take3 = coll1({0, 3});
	fill_99( coll1_take3 );

	auto const& coll2 = coll1;
//  fill_99( coll2 );  // doesn't compile because coll2 is const
//  fill_99( coll2({0, 3}) );  // similar to coll2 | take(3) doesn't compile

	auto const& coll1_take3_const = coll1({0, 3});
//  fill_99( coll1_take3_const );  // doesn't compile because coll1_take3_const is const
}
----

[#tutorial_constexpr]
== Compile-time evaluation (constexpr)

With certain limitations imposed by the language, arrays can be declared in contexts with compile-time evaluation.

[source,cpp]
----
constexpr auto trace() {
	multi::array<int, 2> arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
	arr[2][2] = 10;
	return std::accumulate(arr.diagonal().begin(), arr.diagonal().end());
}

static_assert( trace() == 4 + 2 + 10 );
----
link:https://godbolt.org/z/Porre3z8s[(live)]

[#tutorial_restrictions]
== Restrictions (lazy arrays)

So far, we have examined arrays that contain elements stored in memory; these are referred to as container arrays or concrete arrays, where "concrete arrays" means arrays whose elements are actually stored in memory rather than computed as needed.
In this section, we will describe another type of multidimensional array where elements are not stored but calculated on the fly.
These are called "restrictions arrays" here, also commonly "lazy arrays", and enable delayed evaluation.

Multi's restriction arrays are functions wrapped in a multidimensional array interface.
These functions are restricted (in the mathematical sense) to a discrete range of values in a multidimensional Cartesian grid.
The dimensionality of a restriction is the number of indices or coordinates that this function accepts as inputs.

Restrictions are built from a function (often a lambda) and an `extensions` object.
They are combined with the wedge operator (`operator^`), which resembles an upward arrow.
Unlike concrete arrays, restrictions do not allocate space; elements are generated when needed.

For example, we can restrict this simple function `10*i + j` where `i` and `j` belong to the domain `[0, 2) x [0, 3)` (i.e., `i = 0...1` and `j = 0...2`).

[source,cpp]
----
#include <boost/multi/restrictions.hpp>   // for restrictions/lazy arrays
...
auto R = [](auto i, auto j) { return 10*i + j; } ^ multi::extensions_t<2>(2, 3);
----
Note that `R` does not allocate memory, and it generates values as needed.
For example, `R[1][2]` yields `12` (by performing the operation `10*1 + 2`).

The main property of a restriction array is that it can be generically used in place of a concrete array because it has the same generic interface as `multi::array`, such as `.elements()`, `.transposed()`, `.rotated()`, and (partial) indexing (`operator[]`).
They also provide a complete iterator interface, `.begin()`, `.end()`, `.home()`, and they can be used as standard ranges.
This allows generic algorithms, including some outside Multi, to use these arrays.
As a simple example, the sum of all the elements of `R` is `std::reduce(R.elements().begin(), R.elements().end()).`
(the same expression as if it were a concrete array).

A key difference with concrete arrays is that their elements cannot be changed after creation (i.e., they are immutable). Additionally, concrete arrays do not use internal pointers—addresses that indicate where data is stored—or internal layouts—formats describing the structure of the array—to extract information (e.g., through functions like `.data_elements()`, `.base()`, `.layout()`, or `.stride()`).

An straight forward use for restrictions is for generating concrete arrays from coordinates, replacing common nested initialization loops:

[source,cpp]
----
#include <boost/multi/restrictions.hpp>   // for array values
...
multi::array<int, 2> A({3, 2});

auto [is, js] = A.extensions();

for(auto i : is) {
 for(auto j : js) {
  A[i][j] = 10*i + j;
 }
}
----
... with a simpler construction without intermediate steps:

[source,cpp]
----
multi::array<int, 2> const A = [](auto i, auto j) { return 10*i + j; } ^ multi::extensions_t<2>(3, 2);  // same result as the loop
----

Note that the target array can be conveniently declared `const` if no further mutation is necessary.
Element initialization is delegated to the library here.
Initialization can use optimal hardware- or library-specific operations (e.g., on a GPU) and may occur in any order.

Restrictions apply in many contexts beyond initialization and assignment;
for example, with `std::ranges` or concrete arrays.
In some cases, functions can be generically written to work both on `multi::arrays (or `multi::subarrays) and on restrictions, when a functional programming style is desirable.

For example, this transformation subtracts each row's mean value, row by row:
[source,cpp]
----
auto shift = std::views::transform(
 []<class Row>(Row&& row) {
  auto mean = std::reduce(row.begin(), row.end()) / row.size();
  return std::forward<Row>(row) | std::views::transform([=](auto e) { return e - mean; });
 }
);
----

This operation can be applied to the lazy version or to the concrete version of the array:

[source,cpp]
----
auto lazy = [](auto i, auto j) -> double { return 10 * i + j; } ^ multi::extensions_t<2>(2, 3);  // no allocation
multi::array<double, 2> concrete = {{0.0, 1.0, 2.0}, {10.0, 11.0, 12.0}};  // allocation

auto lazy_shifted = shift(lazy);   // doesn't allocate
auto concrete_shifted = shift(concrete);  // non-allocating; holds reference
----

The main advantage of using lazy arrays and transformation functions is that operations can be performed without requiring temporary arrays or memory allocations.
The allocation would occur only when the result is materialized as a new concrete copy.

[source,cpp]
----
multi::array<double, 2> shift_lazy_copy(shift(lazy));          // allocates here
multi::array<double, 2> shift_concrete_copy(shift(concrete));  // allocates here
----
link:https://godbolt.org/z/qK9cYzrzv[(live)]

Another legitimate and practical use is to leverage the application of standard algorithms on functions (instead of on stored data),
taking advantage of execution in parallel (`std::execution::par` in this example) or on GPU devices (see example in the Interoperability section).

[source,cpp]
----
auto hankel = [](auto i, auto j) { return i + j; }^multi::extensions_t<2>{20, 100};  // or more complicated
auto sum = std::reduce(std::execution::par, hankel[5].begin(), hankel[5].end(), 0);
assert( sum == 100*5 + 100*(100 - 1)/2 );
----
link:https://godbolt.org/z/8bhrjrxGG[(live)]

[#tutorial_broadcast]
== Broadcast (lazy expressions)

The library provides facilities and a set of operator overloads to generate lazily evaluated expressions.
Lazy expressions are useful for generating complex array expressions that are evaluated element-wise without the need for temporary arrays or storage.
These operations include summation and elementwise multiplication, along with most special functions (`exp`, `abs`, `sin`, `cos`, ...).

[source,cpp]
----
#include <boost/multi/broadcast.hpp>  // brings operators, expressions
...
multi::array<int, 2> const A = {{...}};
multi::array<int, 2> const B = {{...}};
multi::array<int, 2> const C = {{...}};

multi::array<int, 2> D = ...;

using multi::elementwise::operator+;  // import elementwise lazy addition
using multi::elementwise::operator*;  // import elementwise lazy multiplication

D = A + B + 2*C + A*B;  // will not generate intermediate arrays and will not allocate if D has already the correct sizes
----
link:https://godbolt.org/z/dsTe6a4T1[(live)]

Composition of operators form lazy expressions.

A key feature of binary operators is that they perform automatic broadcasting and can operate recursively (e.g. for arrays of arrays),
which simplifies notation and is common in modern array languages.
The broadcasting include scalar values, which are promoted to high dimensions as necessary.
In the example below, the scalar `1` is "repeated" and interpreted as `{1, 1, 1}` (without making copies) to match the left operand's (`a`) dimensions.

[source,cpp]
----
multi::array<int, 1> const a = {1, 2, 3};

using multi::broadcast::operator+;
assert(( a + 1 == multi::array<int, 1>({2, 3, 4}) ));
----

Similarly, such a scalar can also be promoted into higher dimensionality if necessary:

[source,cpp]
----
multi::array<int, 2> const A = {
	{1, 2, 3},
	{4, 5, 6}
};

using multi::elementwise::operator+;

assert( A + 1 == multi::array<int, 2>{{2, 3, 4}, {5, 6, 7}} );
----

The same behavior applies to arrays, on either side of the operation:

[source,cpp]
----
    multi::array<int, 2> const A = {{1, 2, 3}, {4, 5, 6}};

    multi::array<int, 1> const b = {1, 2, 3};

    using multi::elementwise::operator+;

    assert(( +(b + A) == multi::array<int, 2>{{2, 4, 6}, {5, 7, 9}} ));
----
Inside the expression, `b` was promoted effectively into a 2D array by repetition (`{{1, 2, 3}, {1, 2, 3}}`).

Operations can be combined in a single expression:

[source,cpp]
----
multi::array<int, 2> const A = {
	{1, 2, 3},
	{4, 5, 6}
};

multi::array<int, 2> const B = {
	{3, 2, 1},
	{6, 5, 4}
};

multi::array<int, 2> const b = {1, 2, 3};

using multi::elementwise::operator+;
using multi::elementwise::operator*;
using multi::elementwise::operator/;  // import elementwise lazy division
using multi::elementwise::exp;        // import elementwise exponentiation

auto const& expr = 2*b + A / exp(B);

assert( expr[2][1] == 2*b[2] + A[2][1] / std::exp(B[2][1]) );
----

Mappings, broadcast and complex expressions can be combined since all of them are specific instances of restrictions.

Expressions can be named variables (e.g., `expr` above), but they generally do not own the objects used in the expression.
Most arrays used in the expression are taken by reference, and array elements are neither copied nor allocated.
Therefore, we should treat expressions as references to arrays, since they do not have independent value semantics.

To use operators, you need to explicitly import them into your current namespace, as shown in the examples -- using `using namespace multi::broadcast` is possible but not recommended.
This is to avoid surprises by confusing broadcast elementwise operations with other common algebraic operations, such as matrix multiplication or matrix exponentiation.
Also as a reminder that these operations return expression objects with referential semantics, not concrete arrays.
For example, returning expressions that refer to local array variables from a C++ function generally will produce dangling references.

Most expressions should be immediately converted to concrete arrays, ideally on a single line.
A common pattern consists of materializing the expression into a concrete array, either by construction or by assignment:

[source,cpp]
----
multi::array<int, 2> expr_copy1 = 2*b + A / exp(B);  // allocate with implied size and initialize elements from the expression evaluation

auto expr_copy2 += (2*b + A / exp(B));  // prefix + evaluates the expression into a concrete array

multi::array<int, 2> expr_copy2({2, 3});
...
expr_copy2 = 2*b + A / exp(B);  // allocation not expected because expr_copy2 has the "right" size, elements are assigned from the expression evaluation
----

Expressions generate special unspecified types, they are internally based on parameterized `multi::restriction` types.
In other C++ libraries, these are know as link:https://en.wikipedia.org/wiki/Expression_templates[Expression Templates] because they leverage heavy templated types.
Unlike other expression-libraries, Multi's lazy expressions are fully integrated with the rest of the library, meaning that they can be utilized generically in the same way as immutable concrete arrays.
(Although they don't have a layout or an internal pointer.)

[source,cpp]
----
template<class Array>
auto trace(Array const& arr) {
	auto const& diag = arr.diagonal();
	return std::reduce(diag.begin(), diag.end());
}
...

multi::array<double, 2> const A = {
	{1.0, 2.0},
	{3.0, 4.0}
};

assert( trace(A) == 1.0 + 4.0 );  // approximately

using multi::elementwise::exp;
assert( trace(exp(A)) == std::exp(1.0) + std::exp(4.0) ); // approximately
----

Custom functions can be applied by using the `multi::elementwise::mapping` function:

[source,cpp]
----
auto const& AVE = multi::elementwise::mapping([](auto a, auto b) { return (a + b) / 2.0 ; }, A, B);
----

Note that lazy expression are themselves multidimensional arrays, and share their generic interface (`.extensions()`, `.size()`, `.begin/end()`, etc) therefore they can be combined with algorithms (or used as part of other expressions)
(e.g. https://godbolt.org/z/Ee1ohKxhW)

// == Broadcast (infinite views)

// Broadcasting is a technique by which arrays are reinterpreted as having a higher dimension by repeating elements.
// The technique allows the reuse of operations designed for high dimensionality and effectively apply them to arrays of lower dimensionality.
// The result is generally an economy in the number of distinct operations that need to be provided in exchange for understanding how and where to exploit the broadcast operations.

// Broadcasting is popular in array-based languages, such as Julia and NumPy, and the broadcast operation is generally applied automatically to match the dimension expected by the operation and other operation inputs.
// The library provides a basic form of broadcasting with certain limitations.

// Here is an example of an algorithm designed for two 2D arrays to obtain the row-by-row inner product.

// ```cpp
// auto row_by_row_dot = [](auto const& A2D, auto const& B2D, auto& results) {
//  std::transform(A2D.begin(), A2D.end(), B2D.begin(), results.begin(),
//      [](auto const& Arow, auto const& Brow) {return std::inner_product(Arow.begin(), Arow.end(), Brow.begin(), 0);}
//  );
// };

// auto A = multi::array<int, 2>{{ 0,  1}, { 2,  3}, { 4,  5}};
// auto B = multi::array<int, 2>{{10, 11}, {12, 13}, {14, 15}};

// auto dots = multi::array<int, 1>({A.size()});

// row_by_row_dot(A, B, dots);
// ```

// If, for some reason, we want to obtain the inner product against a _single_ right-hand vector instead of several (a single 1D array of two elements), we would need to (re)write the function (or copy the repeated vector into the 2D `B` array, which is not ideal.)
// Broadcasting can help reuse the same function without changes.

// ```cpp
// multi::array<int, 1> b = {10, 11};

// row_by_row_dot(A, b.broadcasted(), dots);
// ```

// The alternative, not using broadcast, is to write a very similar function,

// ```cpp
// auto row_fixed_dot = [](auto const& A2D, auto const& b1D, auto& results) {
//  std::transform(A2D.begin(), A2D.end(), results.begin(),
//      [&b1D](auto const& Arow) {return std::inner_product(Arow.begin(), Arow.end(), b1D.begin(), 0);}
//  );
// };

// row_fixed_dot(A, b, dots3);
// ```
// (https://godbolt.org/z/9ndvfKqhc)

// Broadcasted arrays do not behave like normal array views in several aspects:
// First, broadcasted arrays are infinite in the broadcasted dimension; iteration will never reach the end position, and calling `.size()` is undefined behavior.
// Explicit loops or algorithms that depend on reaching `.end()` from `.begin()` will effectively be non-terminating.
// Second, these array views are strictly read-only and alias their element addresses, e.g. `&b.broadcasted()[1][0] == &b.broadcasted()[2][0]` (since internal layouts' strides can be zero).

// <!-- For illustration purposes only, `fill` here is replaced by `copy`; problematic uses are highlighted:

// ```cpp
// multi::array<double, 2> B({10, 2});
// std::fill  (B.begin(), B.end(), b);                                       // canonical way
// std::fill_n(B.begin(), B.size(), b);                                      // canonical way

// std::copy_n(b.broadcasted().begin(), B.size(), B.begin());                // equivalent, using broadcast

// std::copy_n(b.broadcasted().begin(), b.broadcasted().size(), B.begin());  // incorrect, undefined behavior, no useful size()
// std::copy  (b.broadcasted().begin(), b.broadcasted().end(), B.begin());   // incorrect, undefined behavior, non-terminating loop (end is not reacheable)
// B = b.broadcasted();                                                      // incorrect, undefined behavior, B would be of infinite allocated size
// ``` -->

// Unlike in popular languages, broadcasting is not automatic in the library and is applied to the leading dimension only, one dimension at a time.
// Broadcasting in non-leading dimensions can be achieved by transpositions and index rotation.

// Abuse of broadcast can make it harder to reason about operations;
// its primary use is to reuse existing efficient implementations of algorithms when implementations for a specific lower dimensions are not available.
// These algorithms need to be compatible with broadcasted views (e.g., no explicit use of `.size()` or infinite loops stemming from problematic use of `.begin()/end()`.)

// (In STL, algorithms ending with `_n` should be friendly to broadcast arrays, unfortunately `std::copy_n` is sometimes internally implemented in terms of `std::copy` causing a problematic iterator arithmetic on infinite arrays.
// NB: `thrust::copy_n` can be used instead.)

// As a final example, consider a function that computes the elements-by-element product of two 2D arrays,

// ```cpp
// auto hadamard = [](auto const& A, auto const& B, auto&& C) {
//  auto const [is, js] = C.extensions();
//  for(auto i : is) for(auto j : js) C[i][j] = A[i][j]*B[i][j];
// };
// ```

// As it is, this function can be reused to calculate the outer product of two 1D arrays:

// ```cpp
// auto outer = [&]<typename T>(auto const& a, auto const& b, T&& C) {
//  return hadamard(~(a.broadcasted()), b.broadcasted(), std::forward<T>(C));
// };
// ```
// (https://godbolt.org/z/5o95qGdKz)

// Note that the function `hadamard`, acting on 2D arrays, doesn't use the undefined (infinite) sizes (second dimension of `A` and first dimension of `B`).

// NB: A zero-dimensional broadcasts into a one-dimensional.
// Zero-dimensional arrays can contain, at most, one element; and after a broadcast, it can represent an infinite sequence of such element.

// ```cpp
// multi::array<int, 0> const single{7};
// multi::array<int, 1> const sevens = {7, 7, 7};

// single.broadcasted().front() == 7;
// assert( std::equal(sevens.begin(), sevens.end(), single.broadcasted().begin()) );
// ```
// (https://godbolt.org/z/nnxjsrvM1)
