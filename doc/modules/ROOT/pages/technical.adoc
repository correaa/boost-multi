[#technical]

= Technical points (design rationale)

:idprefix: technical_

[#technical_indexing]
== Indexing (square brackets vs. parenthesis?)

The chained bracket notation (`A[i][j][k]`) allows you to refer to elements and lower-dimensional subarrays consistently and generically, and it is the recommended way to access array objects.
It is a frequently raised question whether the chained bracket notation is beneficial for performance, as each use of the bracket leads to the creation of temporary objects, which in turn generates a partial copy of the layout.
Moreover, this goes against link:https://isocpp.org/wiki/faq/operator-overloading#matrix-subscript-op[historical recommendations].

It turns out that modern compilers with a fair level of optimization (`-O2`) can elide these temporary objects so that `A[i][j][k]` generates identical machine code as `A.base() + i*stride1 + j*stride2 + k*stride3` (+offsets not shown).
In a subsequent optimization, constant indices can have their "partial stride" computation removed from loops. 
As a result, these two loops lead to the link:https://godbolt.org/z/eEWWq34Yc[same machine code]:

[source,cpp]
----
	// given the values of i and k and accumulating variable acc ...
    for(long j = 0; j != M; ++j) {acc += A[i][j][k];}
----

[source,cpp]
----
    auto* base = A.base() + i*std::get<0>(A.strides()) + k*std::get<2>(A.strides());
    for(long j = 0; j != M; ++j) {acc += *(base + j*std::get<1>(A.strides()));}
----

Incidentally, the library also supports parenthesis notation with multiple indices `A(i, j, k)` for element or partial access;
it does so as part of a more general syntax to generate sub-blocks.
In any case, `A(i, j, k)` is expanded to `A[i][j][k]` internally in the library when `i`, `j`, and `k` are normal integer indices.
For this reason, `A(i, j, k)`, `A(i, j)(k)`, `A(i)(j)(k)`, `A[i](j)[k]` are examples of equivalent expressions.

(Since C++23, the library also accepts multidimensional subscript notation `A[i, j, k]`)

Sub-block notation, when at least one argument is an index range, e.g., `A({i0, i1}, j, k)` has no equivalent with individual square-bracket notation.
Note also that `A({i0, i1}, j, k)` is not equivalent to `A({i0, i1})(j, k)`; their resulting sublocks have different dimensionality.

Additionally, array coordinates can be directly stored in tuple-like data structures, allowing this functional syntax:

[source,cpp]
----
std::array<int, 3> p = {2, 3, 4};
std::apply(A, p) = 234;  // same as assignment A(2, 3, 4) = 234; and same as A[2][3][4] = 234;
----

Since C++23 (when the `__cpp_multitdimensional_subscript` is available), element access supports multidimensional subscript notation.
In this case, `A[i, j]` is equivalent to `A[i][j]`, and `A[i, j, k]` is equivalent to `A[i][j][k]`, etc., where `i` , `j`, `k`, ... are indices.

[#technical_iteration]
== Iteration past-end in the abstract machine

It's crucial to grasp that pointers are limited to referencing valid memory in the strict C abstract machine, such as allocated memory.
This understanding is key to avoiding undefined behavior in your code.
Since the library iteration is pointer-based, the iterators replicate these restrictions.

There are three cases to consider; the first two can be illustrated with one-dimensional arrays, and one is intrinsic to multiple dimensions.

The first case is that of strided views (e.g. `A.strided(n)`) whose stride value are not divisors of original array size.
The second case is that or negative strides in general.
The third case is that of iterators of transposed array.

In all these cases, the `.end()` iterator may point to invalid memory. 
It's important to note that the act of constructing certain iterators, even if the element is never dereferenced, is undefined in the abstract machine.
This underscores the need for caution when using such operations in your code.

A thorough description of the cases and workaround is beyond the scope of this section.

== Can I change the dimensionality of an array dynamically?

No, dimensionality cannot be set or changed dynamically, this is fundamental to this library.
Dimensionality is part of the type of the array or subarray objects.
This is a choice is make because it is useful to know the dimensionality of an object at compile-time rather than conditionally.
The reason is that in general there are not many algorithms or uses that work in the same way in different dimensions.

The library achieves a different kind of cross-dimensional flexibility by:
a) Treating D-dimensional arrays as, for example, one-dimensional arrays arrays of (D-1)-dimensional subarrays.
In fact, a D-dimensional array can be generated from an array of lower dimensionality

[source,cpp]
----
multi::array<int, 1> A1D = {1, 2, 3};
multi::array<int, 2> A2D(2, A1D);

assert((A2D == multi::array<int, 2>{{1, 2, 3}, {1, 2, 3}}));

assert( A2D[0] == A1D );
assert( A2D[1] == A1D );
----

https://godbolt.org/z/rMEoG3d5c

b) By providing `.elements()` method which gives a flattened view of array of any dimensionality. 

[source,cpp]
----
multi::array<int, 1> A1D = {1, 2, 3};
multi::array<int, 2> A2D = {{1, 2, 3}, {4, 5, 6}};

std::for_each(A1D.elements().begin(), A1D.elements().end(), [](auto&& elem) {elem *= 2;} );
std::for_each(A2D.elements().begin(), A2D.elements().end(), [](auto&& elem) {elem *= 2;} );
----

== Why is dimensionality static and the sizes are dynamic?

Because this is a useful combination for medium to large arrays.
Static sizes can be useful for two different orthogonal reason
a) compile-time arrays,
b) avoid allocations

Different features have different trade-off:

|===
|                         | Pros                                     | Const                                                        

| Dynamic dimensionality  | Avoids (dimension) templates/duck typing | Frequent runtime checks for dimensionality, layout and indices need to be dynamic themselves
| Dynamics sizes          | Runtime adjust sizes              | Requires either allocations or sizes are compile-time bounded
| Fixed sizes             | Can be stack-based/loop unrolling | No runtime choice, imposes small sizes                       
| Stack-based             | Avoids allocations                | Sizes are fixed or 
|===

Here is what the library provides:

|===
| Type                              | Dimensionality   | Sizes                     | Memory                   | Ownership

| `multi::array<T, D>`              | Static           | Dynamic/Mutable           | Heap (allocates)         | Yes, transferable (movable)
| `multi::dynamic_array<T, D>`      | Static           | Dynamic/Immutable         | Heap (allocates)         | Yes, non-transferable (pinned)
| `multi::array_ref<T, D>`          | Static           | Dynamic/Immutable         | Any  (doesn't allocate)  | No, (pinned)
| `multi::subarray<T, D>`           | Static           | Dynamic/Immutable         | Any  (doesn't allocate)  | No, (pinned)
| `multi::inplace_array<T, D, ...>` | Static           | Dynamic/Mutable (bounded) | Stack                    | Yes, non-transferable (pinned)
|===

(note that dimensionality is static --compile-time--)

Other cases can be handled by alternatives by other libraries or not provided directly by the library:

|===
| Type                                                                                       | Dimensionality   | Sizes                          | Memory                   | Ownership

| xtensor, `std::variant<multi::array<T, 1>, multi::array<T, 2>, ...>`, see Python interface | Dynamic          | Dynamic/Mutable                | Heap  (allocates)        | Yes
| `std::mdspan<T, DynamicExt>`                                                               | Static           | Dynamic/Immutable (rebindable) | Any   (doesn't allocate) | No (rebindable)
| `std::mdspan<T, StaticExt>`                                                                | Static           | Static/Immutable (rebindable)  | Any   (allocate)         | No (rebindable)
| `std::mdarray<T, DynamicExt...>` (C++26)                                                   | Static           | Dynamic/Mutable                | Heap  (allocates)        | Yes (container adaptor)
| `std::mdarray<T, StaticExt...>` (C++26)                                                    | Static           | Static or Dynamic/Mutable      | Heap  (allocates)        | Yes (container adaptor)
| `std::array<std::array<T, S1>, S2, ...>`                                                   | Static           | Immutable                      | Stack (doesn't allocate) | No, (pinned)
|===


