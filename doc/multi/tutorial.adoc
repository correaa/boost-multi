[#tutorial]

= Tutorial (advanced usage)

:idprefix: tutorial_

In this example, we are going to use memory that is not managed by the library and manipulate the elements.
We can create a static C-array of `double`s, and refer to it via a bidimensional array `multi::array_ref<double, 2>`.

```cpp
#include <boost/multi/array.hpp>

namespace multi = boost::multi;

int main() {
	double d_data[20] = {
		150.0, 16.0, 17.0, 18.0, 19.0,
		 30.0,  1.0,  2.0,  3.0,  4.0,
		100.0, 11.0, 12.0, 13.0, 14.0,
		 50.0,  6.0,  7.0,  8.0,  9.0
	};  // block of 20 elements ...
	multi::array_ref<double, 2> d2D_ref(&d_data[0], {4, 5});  // .. interpreted as a 4 by 5 array
	...
```

Next, we print the elements in a way that corresponds to the logical arrangement:

```cpp
#include <iostream>  // for print
	...
	auto [is, js] = d2D_ref.extensions();
	for(auto i : is) {
		for(auto j : js) {
			std::cout<< d2D_ref[i][j] <<' ';
		}
		std::cout <<'\n';
	}
```

This will output:

> ```
> 150 16 17 18 19
> 30 1 2 3 4
> 100 11 12 13 14
> 50 6 7 8 9
> ```

The arrays provide iterator-based access, which allows it to interface with algorithms and implement new ones.

It is sometimes said (by Sean Parent) that the whole of STL algorithms can be seen as intermediate pieces to implement `std::stable_sort`.
Presumably, if one can sort over a range, one can perform any other standard algorithm.

```cpp
#include <algorithm>  // for sort
	...
	std::stable_sort( d2D_ref.begin(), d2D_ref.end() );
```

If we print the result again, we get:

> ```
> 30 1 2 3 4
> 50 6 7 8 9
> 100 11 12 13 14
> 150 16 17 18 19
> ```

The array has been changed to be in row-based lexicographical order.
Since the sorted array is a reference to the original data, the original C-array has changed.

(Note that `std::sort` cannot be applied directly to a multidimensional C-array or to other libraries, such as Boost.MultiArray.
The library here are supports all STL algorithms directly.)

If we want to order the matrix on a per-column basis, we need to "view" the matrix as a range of columns.
This is done in the bidimensional case, by accessing the matrix as a range of columns:

```cpp
	...
	std::stable_sort( d2D_ref.rotated().begin(), d2D_ref.rotated().end() );
}
```

The `rotate` operation rotates indices, providing a new logical view of the original array without modifying it.

In this case, the original array will be transformed by sorting the matrix into:

> ```
> 1 2 3 4 30
> 6 7 8 9 50
> 11 12 13 14 100
> 16 17 18 19 150
> ```

https://godbolt.org/z/4zWTPcoK6[(live code)]

By combining index rotations and transpositions, an array of dimension `D` can be viewed simultaneously as `D!` (D-factorial) different ranges of different "transpositions" (rotation/permutation of indices.)

== Initialization

`array_ref` is initialized from a preexisting contiguous range, the index extensions should be compatible with the total number of elements.

```cpp
double* dp = new double[12];
multi::array_ref<double, 2> A({3, 4}, dp);
multi::array_ref<double, 2> B({2, 6}, dp);
...
delete[] dp;
```

Array references do not own memory and, just as language references, can not be rebinded (i.e. resized or "reseated") to refer to a different memory location.
Since `array_ref` is an array reference, it can "dangle" if the original memory is deallocated.

Array objects (`multi::array`), in contrast, own the elements they contain and can be resized later.
An `array` is initialized by specifying the index extensions and, optionally, a default value).

```cpp
multi::array<double, 1> A1({3}      , 11.0);  // {11.0, 11.0, 11.0}

multi::array<double, 2> A2({2, 3}   , 22.0);  // { {22.0, 22.0, 22.}, {22.0, 22.0, 22.0} }

multi::array<double, 3> A3({3, 2, 2}, 33.0);  // { { { 33., ...}, { ... }, ... } }
```
... or alternatively from a rectangular list.

```cpp
multi::array<double, 1> A1 = {1.0, 2.0, 3.0};
assert( num_elements(A1)==3 );

multi::array<double, 2> A2 {
	{ 1.0, 2.0, 3.0},
	{ 4.0, 5.0, 6.0}
};

assert( num_elements(A2) == 2*3);

multi::array<double, 3> const A3 = {
	{{ 1.2,  0.0}, { 2.4, 1.0}},
	{{11.2,  3.0}, {34.4, 4.0}},
	{{15.2, 99.0}, {32.4, 2.0}}
};

assert( A3.num_elements() == 3 * 2 * 2 );
```

In all cases, constness (`const` declaration) is honored in the expected way.
