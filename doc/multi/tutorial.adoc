[#tutorial]

= Tutorial (advanced usage)

:idprefix: tutorial_

In this example, we are going to use memory that is not managed by the library and manipulate the elements.
We can create a static C-array of `double`s, and refer to it via a bidimensional array `multi::array_ref<double, 2>`.

```cpp
#include <boost/multi/array.hpp>

namespace multi = boost::multi;

int main() {
	double d_data[20] = {
		150.0, 16.0, 17.0, 18.0, 19.0,
		 30.0,  1.0,  2.0,  3.0,  4.0,
		100.0, 11.0, 12.0, 13.0, 14.0,
		 50.0,  6.0,  7.0,  8.0,  9.0
	};  // block of 20 elements ...
	multi::array_ref<double, 2> d2D_ref(&d_data[0], {4, 5});  // .. interpreted as a 4 by 5 array
	...
```

Next, we print the elements in a way that corresponds to the logical arrangement:

```cpp
#include <iostream>  // for print
	...
	auto [is, js] = d2D_ref.extensions();
	for(auto i : is) {
		for(auto j : js) {
			std::cout<< d2D_ref[i][j] <<' ';
		}
		std::cout <<'\n';
	}
```

This will output:

> ```
> 150 16 17 18 19
> 30 1 2 3 4
> 100 11 12 13 14
> 50 6 7 8 9
> ```

The arrays provide iterator-based access, which allows it to interface with algorithms and implement new ones.

It is sometimes said (by Sean Parent) that the whole of STL algorithms can be seen as intermediate pieces to implement `std::stable_sort`.
Presumably, if one can sort over a range, one can perform any other standard algorithm.

```cpp
#include <algorithm>  // for sort
	...
	std::stable_sort( d2D_ref.begin(), d2D_ref.end() );
```

If we print the result again, we get:

> ```
> 30 1 2 3 4
> 50 6 7 8 9
> 100 11 12 13 14
> 150 16 17 18 19
> ```

The array has been changed to be in row-based lexicographical order.
Since the sorted array is a reference to the original data, the original C-array has changed.

(Note that `std::sort` cannot be applied directly to a multidimensional C-array or to other libraries, such as Boost.MultiArray.
The library here are supports all STL algorithms directly.)

If we want to order the matrix on a per-column basis, we need to "view" the matrix as a range of columns.
This is done in the bidimensional case, by accessing the matrix as a range of columns:

```cpp
	...
	std::stable_sort( d2D_ref.rotated().begin(), d2D_ref.rotated().end() );
}
```

The `rotate` operation rotates indices, providing a new logical view of the original array without modifying it.

In this case, the original array will be transformed by sorting the matrix into:

> ```
> 1 2 3 4 30
> 6 7 8 9 50
> 11 12 13 14 100
> 16 17 18 19 150
> ```

https://godbolt.org/z/4zWTPcoK6[(live code)]

By combining index rotations and transpositions, an array of dimension `D` can be viewed simultaneously as `D!` (D-factorial) different ranges of different "transpositions" (rotation/permutation of indices.)

== Initialization

`array_ref` is initialized from a preexisting contiguous range, the index extensions should be compatible with the total number of elements.

```cpp
double* dp = new double[12];
multi::array_ref<double, 2> A({3, 4}, dp);
multi::array_ref<double, 2> B({2, 6}, dp);
...
delete[] dp;
```

Array references do not own memory and, just as language references, can not be rebinded (i.e. resized or "reseated") to refer to a different memory location.
Since `array_ref` is an array reference, it can "dangle" if the original memory is deallocated.

Array objects (`multi::array`), in contrast, own the elements they contain and can be resized later.
An `array` is initialized by specifying the index extensions and, optionally, a default value).

```cpp
multi::array<double, 1> A1({3}      , 11.0);  // {11.0, 11.0, 11.0}

multi::array<double, 2> A2({2, 3}   , 22.0);  // { {22.0, 22.0, 22.}, {22.0, 22.0, 22.0} }

multi::array<double, 3> A3({3, 2, 2}, 33.0);  // { { { 33., ...}, { ... }, ... } }
```
... or alternatively from a rectangular list.

```cpp
multi::array<double, 1> A1 = {1.0, 2.0, 3.0};
assert( num_elements(A1)==3 );

multi::array<double, 2> A2 {
	{ 1.0, 2.0, 3.0},
	{ 4.0, 5.0, 6.0}
};

assert( num_elements(A2) == 2*3);

multi::array<double, 3> const A3 = {
	{{ 1.2,  0.0}, { 2.4, 1.0}},
	{{11.2,  3.0}, {34.4, 4.0}},
	{{15.2, 99.0}, {32.4, 2.0}}
};

assert( A3.num_elements() == 3 * 2 * 2 );
```

In all cases, constness (`const` declaration) is honored in the expected way.

== Copy, and assigment (, and aliasing)

The library offers value semantics for the `multi::array<T, D>` family of classes.
Constructing or assigning from an existing array generates a copy of the original object, independent of the original one but equal in value.

```cpp
auto B2 = A2;  // same as multi::array<double, 2> B2 = A2; (A2 is defined above)

assert(  B2       ==  A2       );  // copies have the same element values (and also the same shape)
assert(  B2[0][0] ==  A2[0][0] )
assert( &B2[0][0] != &A2[0][0] );  // but they are independent
```

A (mutable) array can be assigned at any moment, independently of the previous state or shape (extensions).
The dimensionalities must match.
```cpp
B2 = A2;  // both have dimensionality 2
```

Sometimes it is necessary to generate copies from views or subblocks.
```cpp
multi::array<double, 3> C2 = A2( {0, 2}, {0, 2} );
```
or equivalently,
```cpp
auto C2 = + A2( {0, 2}, {0, 2} );
```
Note the use of the prefix `+` as an indicator that a copy must be created (it has no arithmetic implications).
Due to a language limitation, omitting the `+` will create another non-independent reference view of the left-hand side, which is generally undesired.

Subarray-references can also assigned, but only if the shapes of the left-hand side (LHS) and right-hand side (RHS) match.
Otherwise, the behavior is undefined (in debug mode, the program will fail an assertion).

```cpp
C2( {0, 2}, {0, 2} ) = A2( {0, 2}, {0, 2} );  // both are 2x2 views of arrays, *elements* are copied
```

Using the same or overlapping arrays in the RHS and LHS of assignment produces undefined behavior in general (and the library doesn't check).
Notably, this instruction does not transpose the array but produces an undefined result:

```cpp
A2 = A2.transposed();  // undefined result, this is an error
```

This is an instance of the problem of _data aliasing_, which describes a common situation in which a data location in memory can be accessed through different parts of an expression or function call.

This below statement below, instead, does produce a transposition, at the cost of making one copy (implied by `+`) of the transposed array first and assigning (or moving) it back to the original array.

```cpp
A2 = + A2.transposed();  // ok, (might allocate)
```

Within the confines of the library interface, this pitfall can only occur on assignment.
A generic workaround is to use the prefix `operator+`, to break "aliasing" as above.

In general, the problem of aliasing can persist when taking mutable array-references in function arguments.
The most general solution to this problem is to make copies or directly work with completely disjoint objects.
Other case-by-case solutions might be possible.
(For example, in-place transposition (as attempted above) is an active subject of research;
_optimal_ speed and memory transpositions might require specially designed libraries.)

Finally, arrays can be efficiently moved by transferring ownership of the internal data.

```cpp
auto B2 = std::move(A2);  // A2 is empty after this
```

Subarrays do not own the data; therefore they cannot directly take advantage of this feature.
However, individual elements of a view can still be moved; this is particularly useful if the elements are expensive to copy (elements that are containers themselves for exampe).
A "moved" subview is simply another kind of view of the elements.

```cpp
multi::array<std::vector<double>, 2> A({10, 10}, std::vector<double>(1000));
multi::array<std::vector<double>, 2> B({10, 10});
...
B[1] = A[2].element_moved();
```

Each of the 10 *elements* of the third row of `A` is moved into the second row of `B`.
`A[2]` still has 10 (moved-from) empty vectors.


== Change sizes (extents)

Arrays can change their size while _preserving elements_ with the `reextent` method.

```cpp
multi::array<int, 2> A = {
 {1, 2, 3},
 {4, 5, 6}
};

A.reextent({4, 4});

assert( A[0][0] == 1 );
```

An alternative syntax with an additional parameter, `.reextent({...}, value)`, sets _new_ (not preexisting) elements to a specific value.

The primary purpose of `reextent` is element preservation.
All calls to `reextent` allocate and deallocate memory; therefore, they are not amortized.
If element preservation is not desired, a simple assignment (move) from a new array better expresses the intention and is more efficient since it doesn't need to copy preexisting elements.

```cpp
A = multi::array<int, 2>({4, 4});  // extensions like A.reextent({4, 4}) but elements are not preserved

A = multi::array<int, 2>({4, 4}, 99)  // for initialization with specific value 99

A = {};  // empties the array, equivalent to `A.reextent({0, 0});`.
```

Subarrays or views cannot change their size or be emptied (e.g., `A[1].rextent({4})` or `A[1].clear()` will not compile).
For the same reason, subarrays cannot be assigned from an array or another subarray of different size.

Changing the size of arrays by `reextent`, `clear`, or assignment generally invalidates existing iterators and ranges/views.

== Iteration (vs range-loops)

Historically, iteration over arrays has been done with index-based `for`-loops, where each nesting level is associated with a subdimension.
For this type of usage, the valid range of indices in all the dimensions of an array is extracted with `.extensions()`, and in the 2D case, `.extensions()` can be conveniently decomposed into two ranges, one for each dimension.

```cpp
	multi::array<int, 2> A = {
		{1, 2, 3},
		{4, 5, 6}
	};

	auto [is, js] = A.extensions();
	for(auto i : is) {  // is == {0, 1} (range from 0 to 2, not included)
		for(auto j : js) {  // ij = {0, 1, 2} (range from 0 to 3, not included)
			A[i][j] *= 2;
		}
	}
```

Using C++'s range-based for, the elements of the 2D array can be accessed directly without intermediate indices:

```cpp
	for(auto&& row : A) {
		for(auto&& e: row) {  // equivalent to for(auto& e: row) or for(int& e: row)
			e *= 2;
		}
	}
```

However, in some cases it is better to use the iterator-based interface.
The iterator-based interface is more convenient to express and interact with generic algorithms, which in turn can be parallelized and less prone to index errors (such as off-by-one, and out-of-range access.)

Array (and subarray-references) provide a members `.begin()` and `.end()` that produce iterators that access the multidimensional structure through the first dimension (leftmost index).
Accessing arrays by iterators (`begin`/`end`) enables the use of many iterator-based algorithms (see the sort example above).
`begin(A)/end(A)` (or equivalently `A.begin()/A.end()`) gives iterators that are linear and random access in the leading dimension.
Since these iterators are categorized as random-access, arithmetic can be performed on them, for example `it += n;` and `++it` will advance `it` by `n` positions or by one position respectively.

As an alternative, the elements can be iterated in a flat manner, using the `.elements()` member.
This flattening is done in a canonical order (rightmost index changes fastest) and it is provided whether the elements are contiguous or not in memory.
This "elements" range also provides the begin and end iterators (`.elements().begin()`).

Other non-leading dimensions can be obtained by "rotating" indices first.
`A.rotated().begin()/.end()` gives access to a range of subarrays in the second dimension number (the first dimension is put at the end).
(`.cbegin()/.cend()` give constant (read-only) access.)

As an example, this function allows printing arrays of arbitrary dimensionality into a linear comma-separated form.

```cpp
void recursive_print(double const& d) { cout<<d; };  // terminating overload

template<class Array>
void recursive_print(Array const& ma) {
	cout << "{";
	if(! ma.empty()) {
		flat_print(*ma.begin());  // first element
		std::for_each(ma.begin() + 1, ma.end(), [](auto const& e) { cout<<", "; flat_print(e);});  // rest
	}
	cout << "}";
}
...
recursive_print(A);
```
> ```
> {{{1.2, 1.1}, {2.4, 1}}, {{11.2, 3}, {34.4, 4}}, {{15.2, 99}, {32.4, 2}}}
> ```

Except for those corresponding to the one-dimensional case, dereferencing iterators generally produce "proxy"-references (i.e. objects that behave in a large degree like language references).
These references can be given a name; using `auto` can be misleading since the resulting variable does not have value semantics.

```cpp
auto row = *A.begin();  // accepted by the language but misleading, row is *not* a value independent of A
```

In my experience, however, the following usage pattern produces a more consistent idiom for generating references (still without copying elements):

```cpp
auto&&       row0 = *A.begin() ;  // same as decltype(A)::      reference  row0 = * begin(A);
auto const& crow0 = *A.cbegin();  // same as decltype(A)::const_reference crow0 = *cbegin(A);

auto&&       row1 =               A [1];  // same as decltype(A)::      reference  row1 =               A [1];
auto const& crow1 = std::as_const(A)[1];  // same as decltype(A)::const_reference crow0 = std::as_const(A)[1];
```

If a new value is desired, these (equivalent) options express the intention more explicitly:

```cpp
decltype(A)::value_type row =   *begin(A);  // there is a real copy of the row
                   auto row = + *begin(A);  // there is another copy, note the use of '+' (unary plus)
```

In the examples above all elements are accessed in a nested way, recursively down the dimensions.
To iterate over all the elements regardless of the multidimensional structure the following function can print all the elements.

```cpp
template<class Array>
void flat_print(Array const& ma) {
	cout << "[";
	std::for_each(ma.elements().begin(), ma.elements().end(), [](auto&& e) { cout<< e << ", ";});
	cout << "]";
}
...
recursive_print(A);
```
> ```
> [1.2, 1.1, 2.4, 1, 11.2, 3, 34.4, 4, 15.2, 99, 32.4, 2]
> ```

This feature allows to view the array as a flat sequence using the `.elements()` range, which also has `.begin()`/`.end()` and indexing.

// == "Pointer" to subarray

// The library strongly relies on value-semantics, and it doesn't entertain the concept of "shallow" copy;
// however, it supports reference- and pointer-semantics.

// Subarrays (e.g., rows in a 2D array) are reference-like objects with a concrete address-like value that identifies them uniquely.
// These addresses, which behave like pointers, can be helpful to "mark" subviews; these markers can be copied and stored in arrays.

// ```cpp
// auto A = multi::array<double, 2>({4, 4});

// auto row2_ptr = &A[2];  // A[2] is a row of A (not an element)
// assert( row2_ptr == &*(A.begin() + 2) );
// ```

// The expression `A[2]` above is technically a C++ temporary object, and therefore it doesn't have a C++ address (taking `std::addressof` gives a compilation error).
// However, in the library's abstraction, `A[2]` references an existing part of the original array, i.e. it is a "library reference", whose "library address" can be obtained with the `&` operator.
// The case is an illustration that, in the library, operator `&` is, for subarrays, different than the `std::addressof` operator; the latter may not be defined and even not compile for some expressions.

// Comparing these markers/pointers with different provenance, i.e., originating from different arrays, is generally undefined.

== Indexing

Arrays provide random access to elements or subviews.
Many algorithms on arrays are oriented to linear algebra,
which are ubiquitously implemented in terms of multidimensional index access.

Iterator access and index access are two alternatives for accessing elements.
For example `*(begin(A) + n)` and `A[n]` are equivalent
and the range defined by the pair `begin(A), end(A)` is equivalent to `A(extension(A))` and, in turn, to `A()` (even for a multidimensional array, `D > 1`).
The syntax can be combined in arbitrary ways, for example `*begin(A[n])` is equivalent to `A[n][0]`.

== Element access and partial access

Index access mimics that of C-fixed sizes arrays. 
For example, a 2-dimensional array will access to an element by specifying two indices `A[1][2]`,
which can be used for direct write and read operations; 
while _partial_ index arguments `A[1]` generate a view 1-dimensional object (a reference).

```cpp
A        // is a 2D value array
A[0]     // is a 1D "reference"/"view" array
A[0][0]  // is a an element reference, zero-D
```

Transpositions are also multidimensional arrays _views_ in which the index are *logically* rearranged, for example `rotated(m)[2][3][1] == m[1][2][3]`.
(`rotated`/`unrotated` refers to the fact that the logical _indices_ are rotated to the left/right.)

As an illustration of an algorithm based on index access (as opposed to iterators),
this example code implements Gauss Jordan Elimination without pivoting:

```cpp
template<class Matrix, class Vector>
auto gj_solve(Matrix&& A, Vector&& y) -> decltype(y[0]/=A[0][0], y) {
	std::ptrdiff_t Asize = size(A);
	for(std::ptrdiff_t r = 0; r != Asize; ++r) {
		auto&& Ar = A[r];
		auto&& Arr = Ar[r];
		for(std::ptrdiff_t c = r + 1; c != Asize; ++c) {Ar[c] /= Arr;}
		auto const yr = (y[r] /= Arr);
		for(std::ptrdiff_t r2 = r + 1; r2 != Asize; ++r2) {
			auto&& Ar2 = A[r2];
			auto const& Ar2r = Ar2[r];  // auto&& Ar = A[r];
			for(std::ptrdiff_t c = r + 1; c != Asize; ++c) {Ar2[c] -= Ar2r*Ar[c];}
			y[r2] -= Ar2r*yr;
		}
	}
	for(std::ptrdiff_t r = Asize - 1; r > 0; --r) {
		auto const& yr = y[r];
		for(std::ptrdiff_t r2 = r-1; r2 >=0; --r2) {y[r2] -= yr*A[r2][r];}
	}
	return y;
}
```

This function can be applied to a `multi::array` container:

```cpp
multi::array<double, 2> A = {{-3.0, 2.0, -4.0},{0.0, 1.0, 2.0},{2.0, 4.0, 5.0}};
multi::array<double, 1> y = {12.0, 5.0, 2.0};  // (M); assert(y.size() == M); iota(y.begin(), y.end(), 3.1);
gj_solve(A, y);
```

and also to a combination of `MultiArrayView`-type objects (including standard vectors):

```cpp
multi::array<double, 2> A({6000, 7000}); std::iota(A.data_elements(), A.data_elements() + A.num_elements(), 0.1);
std::vector<double> y(3000); std::iota(y.begin(), y.end(), 0.2);  // could be also a multi::array<double, 1> y({3000});
gj_solve(A({1000, 4000}, {0, 3000}), y);
```

== Slices and strides

Given an array, a slice in the first dimension can be taken with the `sliced` function. 
`sliced` takes two arguments, the first index of the slice and the last index (not included) of the slice. For example,

```cpp
multi::array<double, 2> A({4, 5});  // A is a value
assert( std::get<0>(A.sizes()) == 4 );
assert( std::get<1>(A.sizes()) == 5 );

auto&& A_sliced = A.sliced(1, 3); // {{d2D[1], d2D[2]}}
assert( std::get<0>(A_sliced.sizes()) == 2 );
assert( std::get<1>(A_sliced.sizes()) == 5 );
```

The number of rows in the sliced matrix is 2 because we took only two rows, row 1 and row 2 (row 3 is excluded).

In the same way a strided view of the original array can be taken with the `strided` function.

```cpp
auto&& d2D_strided = d2D.strided(2); // {{ d2D[0], d2D[1] }};
assert( d2D_strided.size(0) == 2 and d2D_strided.size(1) == 5 );
```

In this case the number of rows is 2 because, out of the 4 original rows we took one every two.

Operations can be combined in a single line:

```cpp
auto&& d2D_slicedstrided = d2D.sliced(1, 3).strided(2); // {{ d2D[1] }};
assert( std::get<0>(d2D_slicedstrided.sizes()) == 1 and std::get<1>(d2D_slicedstrided.sizes()) == 5 );
```

For convenience, `A.sliced(a, b, c)` is the same as `A.sliced(a, b).strided(c)`.

By combining `rotated`, `sliced` and `strided` one can take sub arrays at any dimension index.
For example in a two dimensional array one can take a subset of columns by defining.

```cpp
auto&& subA = A.rotated().sliced(1, 3).strided(2).unrotated();
```

Other notations are available, for example this is equivalent to `A(multi::_ , {1, 3, /*every*/2})` or `~(~A)({1, 3, 2})`.
The `rotated/strided/sliced/rotated` and combinations of them provides the most control over the subview operations.

Blocks (slices) in multidimensions can be obtained by pure index notation using parentheses `()` (`.operator()`):

```cpp
auto        A = multi::array<double, 2>({6, 7});  // 2D value array

auto&&      A_block1 = A({1, 4}, {2, 4});  // 2D subarray reference (modifiable)
auto const& A_block2 = A({1, 4}, {2, 4});  // 2D subarray reference (non-modifiable)

auto        A_block3 = A({1, 4}, {2, 4});  // works but it can be confusing, use `auto&&` instead
```

Sometimes copies are necessary, specifically from a subarray block, this can be done by constructing a new array. 
The value array can be deduced by using `auto` and the `decay` member, which in turn is equivalent to the prefix `+` operator.

```cpp
multi::array<double, 2> block_value_1 =   A({1, 4}, {2, 4})        ;
auto                    block_value_2 =   A({1, 4}, {2, 4}).decay();
auto                    block_value_3 = + A({1, 4}, {2, 4})        ;
```

Any parenthesis argument can be either a range (with or without stride) or an index. 
Range argument can be substituted by `multi::all` to obtain the whole range.
