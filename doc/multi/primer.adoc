[#primer]

= Primer (basic usage)

:idprefix: primer_

The following code declares an array by specifying the element type and the dimensions;
individual elements can be initialized from a nested rectangular list.
```cpp
multi::array<double, 2> A = {
    {1.0, 2.0, 3.0},
    {4.0, 5.0, 6.0},
};

auto const [n, m] = A.sizes();

assert( n == 2 );  // or std::get<0>(A.sizes()) == 2
assert( m == 3 );  // or std::get<1>(A.sizes()) == 3

assert( A.size() == 2 );  // size in first dimension, same as std::get<0>(A.sizes())
assert( A.num_elements() == 6 );  // total number of elements
```

The value of an array can be copied, (moved,) and compared;
copies are equal but independent (disjoint).

```cpp
std::array<double, 2> B = A;
assert(  B       ==  A                 );  // copies are equal
assert( extensions(B) == extensions(A) );  // extensions (sizes) are equal
assert(  B[0][1] ==  A[0][1]           );  // all elements are equal
assert( &B[0][1] != &A[0][1]           );  // elements are independent (dfferent addresses)
```

Individual elements can be accessed by the multidimensional indices, either with square brackets (one index at a time, as above) or with parenthesis (comma separated).

```cpp
assert( &A(1, 2) ==  &A[1][2] );
```

An array can be initialized from its sizes alone, in which case the element values are defaulted (possibly uninitialized):

```cpp
multi::array<double, 3> C({3, 4, 5});
assert( num_elements(C) == 3*4*5 );   // 60 elements with unspecified values
```

Arrays can be passed by value or by reference.
Most of the time, arguments should be passed through generic parameters to also allow functions to work with parts (subblocks, slices, etc.) of an array.
The most useful functions work on the _concept_ of an array rather than on a concrete type, for example:

```cpp
template<class ArrayDouble2D>  // instead of the overspecific argument std::array<double, 2>
auto element_1_1(ArrayDouble2D const& m) -> double const& { return m[1][1]; }
...
assert( &element_1_1(A) == &A[1][1] );
```

The function expects any array or subarray of dimension 2 and returns an element with type `double`.

The generic function template arguments that are not intended to be modified are passed by `const&`; otherwise, they are passed by forward-reference `&&`.
In this way, the functions can be applied to subblocks of larger matrices.

```cpp
assert( &element_1_1(C3D[0]) == &C3D[0][1][1] );
```

(Although most of the examples use numeric elements for conciseness, the library is designed to hold general types (e.g. non-numeric, non-trivial types, like `std::string`, other containers or, in general, user-defined value-types.)

# Advanced Usage

In this example, we are going to use memory that is not managed by the library and manipulate the elements.
We can create a static C-array of `double`s, and refer to it via a bidimensional array `multi::array_ref<double, 2>`.

```cpp
#include <boost/multi/array.hpp>

namespace multi = boost::multi;

int main() {
	double d_data[20] = {
		150.0, 16.0, 17.0, 18.0, 19.0,
		 30.0,  1.0,  2.0,  3.0,  4.0,
		100.0, 11.0, 12.0, 13.0, 14.0,
		 50.0,  6.0,  7.0,  8.0,  9.0
	};  // block of 20 elements ...
	multi::array_ref<double, 2> d2D_ref(&d_data[0], {4, 5});  // .. interpreted as a 4 by 5 array
	...
```

Next, we print the elements in a way that corresponds to the logical arrangement:

```cpp
#include <iostream>  // for print
	...
	auto [is, js] = d2D_ref.extensions();
	for(auto i : is) {
		for(auto j : js) {
			std::cout<< d2D_ref[i][j] <<' ';
		}
		std::cout <<'\n';
	}
```

This will output:

> ```
> 150 16 17 18 19
> 30 1 2 3 4
> 100 11 12 13 14
> 50 6 7 8 9
> ```

The arrays provide iterator-based access, which allows it to interface with algorithms and implement new ones.

It is sometimes said (by Sean Parent) that the whole of STL algorithms can be seen as intermediate pieces to implement `std::stable_sort`.
Presumably, if one can sort over a range, one can perform any other standard algorithm.

```cpp
#include <algorithm>  // for sort
	...
	std::stable_sort( d2D_ref.begin(), d2D_ref.end() );
```

If we print the result again, we get:

> ```
> 30 1 2 3 4
> 50 6 7 8 9
> 100 11 12 13 14
> 150 16 17 18 19
> ```

The array has been changed to be in row-based lexicographical order.
Since the sorted array is a reference to the original data, the original C-array has changed.

(Note that `std::sort` cannot be applied directly to a multidimensional C-array or to other libraries, such as Boost.MultiArray.
The library here are supports all STL algorithms directly.)

If we want to order the matrix on a per-column basis, we need to "view" the matrix as a range of columns.
This is done in the bidimensional case, by accessing the matrix as a range of columns:

```cpp
	...
	std::stable_sort( d2D_ref.rotated().begin(), d2D_ref.rotated().end() );
}
```

The `rotate` operation rotates indices, providing a new logical view of the original array without modifying it.

In this case, the original array will be transformed by sorting the matrix into:

> ```
> 1 2 3 4 30
> 6 7 8 9 50
> 11 12 13 14 100
> 16 17 18 19 150
> ```

https://godbolt.org/z/4zWTPcoK6[(live code)]

By combining index rotations and transpositions, an array of dimension `D` can be viewed simultaneously as `D!` (D-factorial) different ranges of different "transpositions" (rotation/permutation of indices.)
