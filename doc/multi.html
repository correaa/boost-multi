<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="generator" content="Asciidoctor 2.0.23"/>
<title>Boost.Multi</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"/>
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #24292f;
  background-color: #f6f8fa;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kt, pre.rouge .kv {
  color: #cf222e;
}
pre.rouge .gr {
  color: #f6f8fa;
}
pre.rouge .gd {
  color: #82071e;
  background-color: #ffebe9;
}
pre.rouge .nb {
  color: #953800;
}
pre.rouge .nc {
  color: #953800;
}
pre.rouge .no {
  color: #953800;
}
pre.rouge .nn {
  color: #953800;
}
pre.rouge .sr {
  color: #116329;
}
pre.rouge .na {
  color: #116329;
}
pre.rouge .nt {
  color: #116329;
}
pre.rouge .gi {
  color: #116329;
  background-color: #dafbe1;
}
pre.rouge .kc {
  color: #0550ae;
}
pre.rouge .l, pre.rouge .ld, pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #0550ae;
}
pre.rouge .sb {
  color: #0550ae;
}
pre.rouge .bp {
  color: #0550ae;
}
pre.rouge .ne {
  color: #0550ae;
}
pre.rouge .nl {
  color: #0550ae;
}
pre.rouge .py {
  color: #0550ae;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #0550ae;
}
pre.rouge .o, pre.rouge .ow {
  color: #0550ae;
}
pre.rouge .gh {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .gu {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .se, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1, pre.rouge .ss {
  color: #0a3069;
}
pre.rouge .nd {
  color: #8250df;
}
pre.rouge .nf, pre.rouge .fm {
  color: #8250df;
}
pre.rouge .err {
  color: #f6f8fa;
  background-color: #82071e;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cp, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6e7781;
}
pre.rouge .gl {
  color: #6e7781;
}
pre.rouge .gt {
  color: #6e7781;
}
pre.rouge .ni {
  color: #24292f;
}
pre.rouge .si {
  color: #24292f;
}
pre.rouge .ge {
  color: #24292f;
  font-style: italic;
}
pre.rouge .gs {
  color: #24292f;
  font-weight: bold;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Boost.Multi</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_TOC_">Installation and tests</a></li>
<li><a href="#basic_usage">Basic Usage</a></li>
<li><a href="#advanced_usage">Advanced Usage</a></li>
<li><a href="#initialization">Initialization</a></li>
<li><a href="#copy_and_assigment_and_aliasing">Copy, and assigment (, and aliasing)</a>
<ul class="sectlevel2">
<li><a href="#change_sizes_extents">Change sizes (extents)</a></li>
</ul>
</li>
<li><a href="#iteration_range_based_loops_vs_iterators">Iteration (range-based loops vs iterators)</a>
<ul class="sectlevel2">
<li><a href="#pointer_to_subarray">"Pointer" to subarray</a></li>
</ul>
</li>
<li><a href="#indexing">Indexing</a>
<ul class="sectlevel2">
<li><a href="#element_access_and_partial_access">Element access and partial access</a></li>
<li><a href="#slices_and_strides">Slices and strides</a></li>
</ul>
</li>
<li><a href="#conversions">Conversions</a></li>
<li><a href="#const_correctness">Const-correctness</a></li>
<li><a href="#compile_time_evaluation_constexpr">Compile-time evaluation (constexpr)</a></li>
<li><a href="#broadcast_infinite_views">Broadcast (infinite views)</a></li>
<li><a href="#uninitialized_vs_initialized_elements">Uninitialized vs. initialized elements</a></li>
<li><a href="#type_requirements">Type Requirements</a>
<ul class="sectlevel2">
<li><a href="#linear_sequences_pointers">Linear Sequences: Pointers</a></li>
<li><a href="#special_memory_pointers_and_views">Special Memory: Pointers and Views</a>
<ul class="sectlevel3">
<li><a href="#allocators_and_fancy_pointers">Allocators and Fancy Pointers</a></li>
<li><a href="#transformed_views">Transformed views</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fundamental_types_and_concepts">Fundamental types and concepts</a></li>
<li><a href="#interoperability">Interoperability</a>
<ul class="sectlevel2">
<li><a href="#stl_standard_template_library">STL (Standard Template Library)</a>
<ul class="sectlevel3">
<li><a href="#ranges_c20">Ranges (C++20)</a></li>
<li><a href="#execution_policies_parallel_algorithms">Execution policies (parallel algorithms)</a></li>
<li><a href="#polymorphic_memory_resources">Polymorphic Memory Resources</a></li>
<li><a href="#substitutability_with_standard_vector_and_span">Substitutability with standard vector and span</a></li>
</ul>
</li>
<li><a href="#serialization">Serialization</a></li>
<li><a href="#range_v3">Range-v3</a></li>
<li><a href="#boost_interprocess">Boost.Interprocess</a></li>
<li><a href="#cuda_and_hip_and_omp_and_tbb_via_thrust">CUDA (and HIP, and OMP, and TBB) via Thrust</a>
<ul class="sectlevel3">
<li><a href="#openmp_via_thrust">OpenMP via Thrust</a></li>
<li><a href="#thrust_memory_resources">Thrust memory resources</a></li>
</ul>
</li>
<li><a href="#cuda_c">CUDA C++</a></li>
<li><a href="#sycl">SYCL</a></li>
<li><a href="#formatting_fmt_pretty_printing">Formatting ({fmt} pretty printing)</a></li>
<li><a href="#legacy_libraries_c_apis">Legacy libraries (C-APIs)</a></li>
</ul>
</li>
<li><a href="#technical_points">Technical points</a>
<ul class="sectlevel2">
<li><a href="#indexing_square_brackets_vs_parenthesis">Indexing (square brackets vs. parenthesis?)</a></li>
<li><a href="#iteration_past_end_in_the_abstract_machine">Iteration past-end in the abstract machine</a></li>
</ul>
</li>
<li><a href="#appendix_comparison_to_other_array_libraries_mdspan_boost_multiarray_etc">Appendix: Comparison to other array libraries (mdspan, Boost.MultiArray, etc)</a></li>
<li><a href="#appendix_multi_for_fortran_programmers">Appendix: Multi for FORTRAN programmers</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<style>
.imageblock > .title {
  text-align: inherit;
}

.indent {
  padding-left: 2rem;
}

.bordered_table th, .bordered_table td {
  border: 1px solid lightgray;
}
</style>
<div class="paragraph">
<p><strong>[Boost.] Multi</strong></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Disclosure: This is not an official or accepted Boost library and is unrelated to the std::mdspan proposal. It is in the process of being proposed for inclusion in [Boost](<a href="https://www.boost.org/" class="bare">https://www.boost.org/</a>) and it doesn&#8217;t depend on Boost libraries.</strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><em>Â© Alfredo A. Correa, 2018-2025</em></p>
</div>
<div class="paragraph">
<p><em>Multi</em> is a modern C++ library that provides manipulation and access of data in multidimensional arrays for both CPU and GPU memory.</p>
</div>
<div class="paragraph">
<p>Multidimensional array data structures are fundamental to several branches of computing, such as data analysis, image processing, and scientific simulations, and in combination with GPUs to Artificial Intelligence and Machine Learning.
This library offers array containers and subarrays in arbitrary dimensions with well-behaved value semantics,
featuring logical access recursively across dimensions and to elements through indices and iterators.</p>
</div>
<div class="paragraph">
<p>The internal data structure layout is stride-based, which makes it compatible with low-level C libraries.</p>
</div>
<div class="paragraph">
<p>The library interface is designed to be compatible with standard algorithms and ranges (STL) and special memory (including GPUs) and follows modern C++ design principles.</p>
</div>
<div class="paragraph">
<p>Features of this library that aim to facilitate the manipulation of multidimensional arrays include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Value semantics of multidimensional array containers and well-defined referential semantics to avoid unnecessary copies if possible.</p>
</li>
<li>
<p>Availability of different access patterns to the elements in the multidimensional structure, as nested sequences or as a single sequence of elements.
A <em>D</em>-dimensional array can be interpreted either as an (STL-compatible) sequence of (<em>D</em>-1)-dimensional subarrays or as a flattened one-dimensional (also STL-compatible) sequence of elements.</p>
</li>
<li>
<p>Interoperability with both legacy C and modern C++ libraries (e.g., STL, ranges, Thrust --CUDA and AMD GPUs--, Boost).</p>
</li>
<li>
<p>Memory management and allocation to exploit modern memory spaces, including GPU memory, mapped memory, and fancy pointers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Do not confuse this library with [Boost.MultiArray](<a href="https://www.boost.org/doc/libs/1_69_0/libs/multi_array/doc/index.html" class="bare">https://www.boost.org/doc/libs/1_69_0/libs/multi_array/doc/index.html</a>) 
or with the standard MDSpan proposal <code>std::mdspan</code>.
This library shares some of their goals and is compatible with them, but it is designed at a different level of generality and with other priorities (such as the features listed above).
The code is entirely independent and has fundamental implementation and semantics differences.</p>
</div>
<div class="paragraph">
<p>The library&#8217;s primary concern is with the storage and logic structure of data;
it doesn&#8217;t make algebraic or geometric assumptions about the arrays and their elements.
(It is still a good building block for implementing mathematical algorithms, such as representing algebraic dense matrices in the 2D case.)</p>
</div>
<div class="paragraph">
<p>The library does not throw exceptions and provides basic guarantees (such as no memory leaks) in their presence (e.g., thrown from allocations).
Indexing and other logical errors result in undefined behavior, which this library attempts to reflect via assertions.</p>
</div>
<div class="paragraph">
<p>The library requires C++17 or higher, and it has no external dependencies.</p>
</div>
<div class="paragraph">
<p><strong>Contents:</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_TOC_"><a class="link" href="#_TOC_">Installation and tests</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before using the library, you can try it [online](<a href="https://godbolt.org/z/dvacqK8jE" class="bare">https://godbolt.org/z/dvacqK8jE</a>).</p>
</div>
<div class="paragraph">
<p><em>Multi</em> doesn&#8217;t require installation; a single header <code>#include &lt;multi/array.hpp&gt;</code> is enough to use the entire core library.
<em>Multi</em> has no dependencies (except for the standard C++ library) and can be used immediately after downloading.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">git clone https://gitlab.com/correaa/boost-multi.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although installation is unnecessary, the library can still be installed with CMake.
The header (and CMake) files will be installed in the chosen prefix location (by default, <code>/usr/local/include/multi</code> and <code>/usr/local/share/multi</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="nb">cd </span>boost-multi
<span class="nb">mkdir</span> <span class="nt">-p</span> build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake ..  <span class="c"># --install-prefix=$HOME/.local</span>
cmake <span class="nt">--install</span> <span class="nb">.</span>  <span class="c"># or sudo ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Testing</em> the library requires the Boost.Test library, installed for example, via <code>sudo apt install cmake git g libboost-test-dev make` or `sudo dnf install boost-devel cmake gcc-c git</code>.
A CMake build system is provided to compile and run basic tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">cmake <span class="nt">--build</span> <span class="nb">.</span>
ctest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once installed, other CMake projects (targets) can depend on Multi by adding a simple <code>add_subdirectory(my_multi_path)</code> or by <code>find_package</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cmake"><span class="nb">find_package</span><span class="p">(</span>multi<span class="p">)</span>  <span class="c1"># see https://gitlab.com/correaa/boost-multi#using-the-library-installation-and-tests</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternatively to using <code>find_package</code>, the library can be fetched on demand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cmake"><span class="nb">include</span><span class="p">(</span>FetchContent<span class="p">)</span>
<span class="nf">FetchContent_Declare</span><span class="p">(</span>multi GIT_REPOSITORY https://gitlab.com/correaa/boost-multi.git<span class="p">)</span>
<span class="nf">FetchContent_MakeAvailable</span><span class="p">(</span>multi<span class="p">)</span>
...
<span class="nb">target_link_libraries</span><span class="p">(</span>my_target PUBLIC multi<span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code requires [any C compiler](https://godbolt.org/z/hxEYGYEWc) (or [CUDA compiler](https://godbolt.org/z/79Tqedhfs)) with standard C17 support;
for reference, any of:
LLVM&#8217;s       <code>clang</code> [(5.0+)](<a href="https://godbolt.org/z/51E1hjfnn" class="bare">https://godbolt.org/z/51E1hjfnn</a>) (<code>libc` and `libstdc</code>),
GNU&#8217;s        <code>g` [(7.1+)](https://godbolt.org/z/1nGEbKc5a),
Nvidia's    [`nvcc`](https://godbolt.org/z/abdT73PqM) (11.4+) 
and 
            [`nvc</code>](<a href="https://godbolt.org/z/6z39PjT47" class="bare">https://godbolt.org/z/6z39PjT47</a>) (22.7+),
Intel&#8217;s      <code>icpx</code> (2022.0.0+) and <code>icc</code> (2021.1.2+, deprecated),
Baxter&#8217;s    [<code>circle</code>](<a href="https://www.circle-lang.org/" class="bare">https://www.circle-lang.org/</a>) ([build 202+](<a href="https://godbolt.org/z/KeG417fMz" class="bare">https://godbolt.org/z/KeG417fMz</a>)),
[Zig](<a href="https://zig.news/kristoff/compile-a-c-c-project-with-zig-368j" class="bare">https://zig.news/kristoff/compile-a-c-c-project-with-zig-368j</a>) in [c++ mode (v0.9.0+)](<a href="https://godbolt.org/z/cKGebsWMG" class="bare">https://godbolt.org/z/cKGebsWMG</a>),
Edison Desing&#8217;s [EDG]() [(6.5+)](<a href="https://godbolt.org/z/693fxPedx" class="bare">https://godbolt.org/z/693fxPedx</a>)
and
Microsoft&#8217;s [MSVC](<a href="https://visualstudio.microsoft.com/vs/features/cplusplus/" class="bare">https://visualstudio.microsoft.com/vs/features/cplusplus/</a>) ([+14.1](<a href="https://godbolt.org/z/Kqrva137M" class="bare">https://godbolt.org/z/Kqrva137M</a>)).</p>
</div>
<div class="paragraph">
<p>(Multi code inside CUDA kernel can be compiled with <code>nvcc</code> and with [<code>clang</code> (in CUDA mode)](<a href="https://godbolt.org/z/7dTKdPTxc" class="bare">https://godbolt.org/z/7dTKdPTxc</a>).
Inside HIP code, it can be compiled with AMD&#8217;s clang rocm (5.0+).)</p>
</div>
<div class="paragraph">
<p>Optional "adaptor" sublibraries (included in <code>multi/adaptors/</code>) have specific dependencies: fftw, , lapack, thurst, or CUDA
(all of them can be installed with <code>sudo apt install libfftw3-dev lib64-dev liblapack64-dev libthrust-dev nvidia-cuda-dev</code> or <code>sudo dnf install -devel fftw-devel &#8230;&#8203;</code>.)</p>
</div>
<div class="paragraph">
<p>In the following sections we present basic and advanced uses of the libraries. 
Feel free to jump to the "Reference of fundamental types" section to explore a more exhaustive description of the classes provided by the library.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basic_usage"><a class="link" href="#basic_usage">Basic Usage</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following code declares an array by specifying the element type and the dimensions;
individual elements can be initialized from a nested rectangular list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="k">const</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">sizes</span><span class="p">();</span>

<span class="n">assert</span><span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>  <span class="c1">// or std::get&lt;0&gt;(A.sizes()) == 2</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">);</span>  <span class="c1">// or std::get&lt;1&gt;(A.sizes()) == 3</span>

<span class="n">assert</span><span class="p">(</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>  <span class="c1">// size in first dimension, same as std::get&lt;0&gt;(A.sizes())</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">A</span><span class="p">.</span><span class="n">num_elements</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">);</span>  <span class="c1">// total number of elements</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of an array can be copied, (moved,) and compared;
copies are equal but independent (disjoint).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span>  <span class="n">B</span>       <span class="o">==</span>  <span class="n">A</span>                 <span class="p">);</span>  <span class="c1">// copies are equal</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">extensions</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="n">extensions</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">// extensions (sizes) are equal</span>
<span class="n">assert</span><span class="p">(</span>  <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span>  <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>           <span class="p">);</span>  <span class="c1">// all elements are equal</span>
<span class="n">assert</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>           <span class="p">);</span>  <span class="c1">// elements are independent (dfferent addresses)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Individual elements can be accessed by the multidimensional indices, either with square brackets (one index at a time, as above) or with parenthesis (comma separated).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">assert</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span>  <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An array can be initialized from its sizes alone, in which case the element values are defaulted (possibly uninitialized):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">C</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">});</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">num_elements</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span> <span class="p">);</span>   <span class="c1">// 60 elements with unspecified values</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Arrays can be passed by value or by reference.
Most of the time, arguments should be passed through generic parameters to also allow functions to work with parts (subblocks, slices, etc.) of an array.
The most useful functions work on the <em>concept</em> of an array rather than on a concrete type, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ArrayDouble2D</span><span class="p">&gt;</span>  <span class="c1">// instead of the overspecific argument std::array&lt;double, 2&gt;</span>
<span class="k">auto</span> <span class="n">element_1_1</span><span class="p">(</span><span class="n">ArrayDouble2D</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="p">}</span>
<span class="p">...</span>
<span class="n">assert</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">element_1_1</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The function expects any array or subarray of dimension 2 and returns an element with type <code>double</code>.</p>
</div>
<div class="paragraph">
<p>The generic function template arguments that are not intended to be modified are passed by <code>const&amp;</code>; otherwise, they are passed by forward-reference <code>&amp;&amp;</code>.
In this way, the functions can be applied to subblocks of larger matrices.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">assert</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">element_1_1</span><span class="p">(</span><span class="n">C3D</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">C3D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(Although most of the examples use numeric elements for conciseness, the library is designed to hold general types (e.g. non-numeric, non-trivial types, like <code>std::string</code>, other containers or, in general, user-defined value-types.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced_usage"><a class="link" href="#advanced_usage">Advanced Usage</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this example, we are going to use memory that is not managed by the library and manipulate the elements.
We can create a static C-array of <code>double`s, and refer to it via a bidimensional array `multi::array_ref&lt;double, 2&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;boost/multi/array.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">multi</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">double</span> <span class="n">d_data</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mf">150.0</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">17.0</span><span class="p">,</span> <span class="mf">18.0</span><span class="p">,</span> <span class="mf">19.0</span><span class="p">,</span>
		 <span class="mf">30.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">2.0</span><span class="p">,</span>  <span class="mf">3.0</span><span class="p">,</span>  <span class="mf">4.0</span><span class="p">,</span>
		<span class="mf">100.0</span><span class="p">,</span> <span class="mf">11.0</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">,</span> <span class="mf">13.0</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">,</span>
		 <span class="mf">50.0</span><span class="p">,</span>  <span class="mf">6.0</span><span class="p">,</span>  <span class="mf">7.0</span><span class="p">,</span>  <span class="mf">8.0</span><span class="p">,</span>  <span class="mf">9.0</span>
	<span class="p">};</span>  <span class="c1">// block of 20 elements ...</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array_ref</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">d2D_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">});</span>  <span class="c1">// .. interpreted as a 4 by 5 array</span>
	<span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we print the elements in a way that corresponds to the logical arrangement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">  // for print</span><span class="cp">
</span>	<span class="p">...</span>
	<span class="k">auto</span> <span class="p">[</span><span class="n">is</span><span class="p">,</span> <span class="n">js</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2D_ref</span><span class="p">.</span><span class="n">extensions</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">is</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">:</span> <span class="n">js</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">d2D_ref</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will output:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="mi">150</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span>
<span class="mi">30</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="mi">100</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span>
<span class="mi">50</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span></code></pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The arrays provide iterator-based access, which allows it to interface with algorithms and implement new ones.</p>
</div>
<div class="paragraph">
<p>It is sometimes said (by Sean Parent) that the whole of STL algorithms can be seen as intermediate pieces to implement <code>std::stable_sort</code>.
Presumably, if one can sort over a range, one can perform any other standard algorithm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="c1">  // for sort</span><span class="cp">
</span>	<span class="p">...</span>
	<span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span> <span class="n">d2D_ref</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">d2D_ref</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we print the result again, we get:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="mi">30</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="mi">50</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
<span class="mi">100</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span>
<span class="mi">150</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span></code></pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The array has been changed to be in row-based lexicographical order.
Since the sorted array is a reference to the original data, the original C-array has changed.</p>
</div>
<div class="paragraph">
<p>(Note that <code>std::sort</code> cannot be applied directly to a multidimensional C-array or to other libraries, such as Boost.MultiArray.
The library here are supports all STL algorithms directly.)</p>
</div>
<div class="paragraph">
<p>If we want to order the matrix on a per-column basis, we need to "view" the matrix as a range of columns.
This is done in the bidimensional case, by accessing the matrix as a range of columns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="p">...</span>
	<span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span> <span class="n">d2D_ref</span><span class="p">.</span><span class="n">rotated</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">d2D_ref</span><span class="p">.</span><span class="n">rotated</span><span class="p">().</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>rotate</code> operation rotates indices, providing a new logical view of the original array without modifying it.</p>
</div>
<div class="paragraph">
<p>In this case, the original array will be transformed by sorting the matrix into:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">30</span>
<span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">50</span>
<span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">100</span>
<span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">150</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>([live code](<a href="https://godbolt.org/z/4zWTPcoK6" class="bare">https://godbolt.org/z/4zWTPcoK6</a>))</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>By combining index rotations and transpositions, an array of dimension <code>D</code> can be viewed simultaneously as <code>D!</code> (D-factorial) different ranges of different "transpositions" (rotation/permutation of indices.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initialization"><a class="link" href="#initialization">Initialization</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>array_ref</code> is initialized from a preexisting contiguous range, the index extensions should be compatible with the total number of elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">double</span><span class="o">*</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array_ref</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="n">dp</span><span class="p">);</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array_ref</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="n">dp</span><span class="p">);</span>
<span class="p">...</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">dp</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Array references do not own memory and, just as language references, can not be rebinded (i.e. resized or "reseated") to refer to a different memory location.
Since <code>array_ref</code> is an array reference, it can "dangle" if the original memory is deallocated.</p>
</div>
<div class="paragraph">
<p>Array objects (<code>multi::array</code>), in contrast, own the elements they contain and can be resized later.
An <code>array</code> is initialized by specifying the index extensions and, optionally, a default value).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">A1</span><span class="p">({</span><span class="mi">3</span><span class="p">}</span>      <span class="p">,</span> <span class="mf">11.0</span><span class="p">);</span>  <span class="c1">// {11.0, 11.0, 11.0}</span>

<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A2</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>   <span class="p">,</span> <span class="mf">22.0</span><span class="p">);</span>  <span class="c1">// { {22.0, 22.0, 22.}, {22.0, 22.0, 22.0} }</span>

<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">A3</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="mf">33.0</span><span class="p">);</span>  <span class="c1">// { { { 33., ...}, { ... }, ... } }</span></code></pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>or alternatively from a rectangular list.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">A1</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">};</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">num_elements</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="p">);</span>

<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A2</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">},</span>
	<span class="p">{</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">}</span>
<span class="p">};</span>

<span class="n">assert</span><span class="p">(</span> <span class="n">num_elements</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>

<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">A3</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{{</span> <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">},</span> <span class="p">{</span> <span class="mf">2.4</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">}},</span>
	<span class="p">{{</span><span class="mf">11.2</span><span class="p">,</span>  <span class="mf">3.0</span><span class="p">},</span> <span class="p">{</span><span class="mf">34.4</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">}},</span>
	<span class="p">{{</span><span class="mf">15.2</span><span class="p">,</span> <span class="mf">99.0</span><span class="p">},</span> <span class="p">{</span><span class="mf">32.4</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">}}</span>
<span class="p">};</span>

<span class="n">assert</span><span class="p">(</span> <span class="n">A3</span><span class="p">.</span><span class="n">num_elements</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In all cases, constness (<code>const</code> declaration) is honored in the expected way.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copy_and_assigment_and_aliasing"><a class="link" href="#copy_and_assigment_and_aliasing">Copy, and assigment (, and aliasing)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The library offers value semantics for the <code>multi::array&lt;T, D&gt;</code> family of classes.
Constructing or assigning from an existing array generates a copy of the original object, independent of the original one but equal in value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">B2</span> <span class="o">=</span> <span class="n">A2</span><span class="p">;</span>  <span class="c1">// same as multi::array&lt;double, 2&gt; B2 = A2; (A2 is defined above)</span>

<span class="n">assert</span><span class="p">(</span>  <span class="n">B2</span>       <span class="o">==</span>  <span class="n">A2</span>       <span class="p">);</span>  <span class="c1">// copies have the same element values (and also the same shape)</span>
<span class="n">assert</span><span class="p">(</span>  <span class="n">B2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>  <span class="n">A2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="n">assert</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">B2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">A2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>  <span class="c1">// but they are independent</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A (mutable) array can be assigned at any moment, independently of the previous state or shape (extensions).
The dimensionalities must match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">B2</span> <span class="o">=</span> <span class="n">A2</span><span class="p">;</span>  <span class="c1">// both have dimensionality 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes it is necessary to generate copies from views or subblocks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">A2</span><span class="p">(</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>or equivalently,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">C2</span> <span class="o">=</span> <span class="o">+</span> <span class="n">A2</span><span class="p">(</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the use of the prefix <code>` as an indicator that a copy must be created (it has no arithmetic implications).
Due to a language limitation, omitting the `</code> will create another non-independent reference view of the left-hand side, which is generally undesired.</p>
</div>
<div class="paragraph">
<p>Subarray-references can also assigned, but only if the shapes of the left-hand side (LHS) and right-hand side (RHS) match.
Otherwise, the behavior is undefined (in debug mode, the program will fail an assertion).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">C2</span><span class="p">(</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="p">)</span> <span class="o">=</span> <span class="n">A2</span><span class="p">(</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="p">);</span>  <span class="c1">// both are 2x2 views of arrays, *elements* are copied</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the same or overlapping arrays in the RHS and LHS of assignment produces undefined behavior in general (and the library doesn&#8217;t check).
Notably, this instruction does not transpose the array but produces an undefined result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">A2</span> <span class="o">=</span> <span class="n">A2</span><span class="p">.</span><span class="n">transposed</span><span class="p">();</span>  <span class="c1">// undefined result, this is an error</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an instance of the problem of <em>data aliasing</em>, which describes a common situation in which a data location in memory can be accessed through different parts of an expression or function call.</p>
</div>
<div class="paragraph">
<p>This below statement below, instead, does produce a transposition, at the cost of making one copy (implied by <code>+</code>) of the transposed array first and assigning (or moving) it back to the original array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">A2</span> <span class="o">=</span> <span class="o">+</span> <span class="n">A2</span><span class="p">.</span><span class="n">transposed</span><span class="p">();</span>  <span class="c1">// ok, (might allocate)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Within the confines of the library interface, this pitfall can only occur on assignment.
A generic workaround is to use the prefix <code>operator+</code>, to break "aliasing" as above.</p>
</div>
<div class="paragraph">
<p>In general, the problem of aliasing can persist when taking mutable array-references in function arguments.
The most general solution to this problem is to make copies or directly work with completely disjoint objects.
Other case-by-case solutions might be possible.
(For example, in-place transposition (as attempted above) is an active subject of research;
<em>optimal</em> speed and memory transpositions might require specially designed libraries.)</p>
</div>
<div class="paragraph">
<p>Finally, arrays can be efficiently moved by transferring ownership of the internal data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">B2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">A2</span><span class="p">);</span>  <span class="c1">// A2 is empty after this</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Subarrays do not own the data; therefore they cannot directly take advantage of this feature.
However, individual elements of a view can still be moved; this is particularly useful if the elements are expensive to copy (elements that are containers themselves for exampe).
A "moved" subview is simply another kind of view of the elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">});</span>
<span class="p">...</span>
<span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">element_moved</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of the 10 <strong>elements</strong> of the third row of <code>A</code> is moved into the second row of <code>B</code>.
<code>A[2]</code> still has 10 (moved-from) empty vectors.</p>
</div>
<div class="sect2">
<h3 id="change_sizes_extents"><a class="link" href="#change_sizes_extents">Change sizes (extents)</a></h3>
<div class="paragraph">
<p>Arrays can change their size while <em>preserving elements</em> with the <code>reextent</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{</span>
 <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
 <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="p">};</span>

<span class="n">A</span><span class="p">.</span><span class="n">reextent</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">});</span>

<span class="n">assert</span><span class="p">(</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative syntax with an additional parameter, <code>.reextent({&#8230;&#8203;}, value)</code>, sets <em>new</em> (not preexisting) elements to a specific value.</p>
</div>
<div class="paragraph">
<p>The primary purpose of <code>reextent</code> is element preservation.
All calls to <code>reextent</code> allocate and deallocate memory; therefore, they are not amortized.
If element preservation is not desired, a simple assignment (move) from a new array better expresses the intention and is more efficient since it doesn&#8217;t need to copy preexisting elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">A</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">});</span>  <span class="c1">// extensions like A.reextent({4, 4}) but elements are not preserved</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="mi">99</span><span class="p">)</span>  <span class="c1">// for initialization with specific value 99</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">{};</span>  <span class="c1">// empties the array, equivalent to `A.reextent({0, 0});`.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Subarrays or views cannot change their size or be emptied (e.g., <code>A[1].rextent({4})</code> or <code>A[1].clear()</code> will not compile).
For the same reason, subarrays cannot be assigned from an array or another subarray of different size.</p>
</div>
<div class="paragraph">
<p>Changing the size of arrays by <code>reextent</code>, <code>clear</code>, or assignment generally invalidates existing iterators and ranges/views.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="iteration_range_based_loops_vs_iterators"><a class="link" href="#iteration_range_based_loops_vs_iterators">Iteration (range-based loops vs iterators)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Historically, iteration over arrays has been done with index-based <code>for</code>-loops, where each nesting level is associated with a subdimension.
For this type of usage, the valid range of indices in all the dimensions of an array is extracted with <code>.extensions()</code>, and in the 2D case, <code>.extensions()</code> can be conveniently decomposed into two ranges, one for each dimension.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
		<span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
	<span class="p">};</span>

	<span class="k">auto</span> <span class="p">[</span><span class="n">is</span><span class="p">,</span> <span class="n">js</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">extensions</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">is</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// is == {0, 1} (range from 0 to 2, not included)</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">:</span> <span class="n">js</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// ij = {0, 1, 2} (range from 0 to 3, not included)</span>
			<span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using C++'s range-based for, the elements of the 2D array can be accessed directly without intermediate indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">:</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">:</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// equivalent to for(auto&amp; e: row) or for(int&amp; e: row)</span>
			<span class="n">e</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, in some cases it is better to use the iterator-based interface.
The iterator-based interface is more convenient to express and interact with generic algorithms, which in turn can be parallelized and less prone to index errors (such as off-by-one, and out-of-range access.)</p>
</div>
<div class="paragraph">
<p>Array (and subarray-references) provide a members <code>.begin()</code> and <code>.end()</code> that produce iterators that access the multidimensional structure through the first dimension (leftmost index).
Accessing arrays by iterators (<code>begin</code>/<code>end</code>) enables the use of many iterator-based algorithms (see the sort example above).
<code>begin(A)/end(A)</code> (or equivalently <code>A.begin()/A.end()</code>) gives iterators that are linear and random access in the leading dimension.
Since these iterators are categorized as random-access, arithmetic can be performed on them, for example <code>it = n;` and `+it</code> will advance <code>it</code> by <code>n</code> positions or by one position respectively.</p>
</div>
<div class="paragraph">
<p>As an alternative, the elements can be iterated in a flat manner, using the <code>.elements()</code> member.
This flattening is done in a canonical order (rightmost index changes fastest) and it is provided whether the elements are contiguous or not in memory.
This "elements" range also provides the begin and end iterators (<code>.elements().begin()</code>).</p>
</div>
<div class="paragraph">
<p>Other non-leading dimensions can be obtained by "rotating" indices first.
<code>A.rotated().begin()/.end()</code> gives access to a range of subarrays in the second dimension number (the first dimension is put at the end).
(<code>.cbegin()/.cend()</code> give constant (read-only) access.)</p>
</div>
<div class="paragraph">
<p>As an example, this function allows printing arrays of arbitrary dimensionality into a linear comma-separated form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">void</span> <span class="nf">recursive_print</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">d</span><span class="p">;</span> <span class="p">};</span>  <span class="c1">// terminating overload</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Array</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">recursive_print</span><span class="p">(</span><span class="n">Array</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ma</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"{"</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">ma</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">flat_print</span><span class="p">(</span><span class="o">*</span><span class="n">ma</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>  <span class="c1">// first element</span>
		<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">ma</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ma</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">", "</span><span class="p">;</span> <span class="n">flat_print</span><span class="p">(</span><span class="n">e</span><span class="p">);});</span>  <span class="c1">// rest</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"}"</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">recursive_print</span><span class="p">(</span><span class="n">A</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">{{{</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">},</span> <span class="p">{</span><span class="mf">2.4</span><span class="p">,</span> <span class="mi">1</span><span class="p">}},</span> <span class="p">{{</span><span class="mf">11.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mf">34.4</span><span class="p">,</span> <span class="mi">4</span><span class="p">}},</span> <span class="p">{{</span><span class="mf">15.2</span><span class="p">,</span> <span class="mi">99</span><span class="p">},</span> <span class="p">{</span><span class="mf">32.4</span><span class="p">,</span> <span class="mi">2</span><span class="p">}}}</span></code></pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Except for those corresponding to the one-dimensional case, dereferencing iterators generally produce "proxy"-references (i.e. objects that behave in a large degree like language references).
These references can be given a name; using <code>auto</code> can be misleading since the resulting variable does not have value semantics.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">row</span> <span class="o">=</span> <span class="o">*</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">// accepted by the language but misleading, row is *not* a value independent of A</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In my experience, however, the following usage pattern produces a more consistent idiom for generating references (still without copying elements):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span>       <span class="n">row0</span> <span class="o">=</span> <span class="o">*</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">;</span>  <span class="c1">// same as decltype(A)::      reference  row0 = * begin(A);</span>
<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">crow0</span> <span class="o">=</span> <span class="o">*</span><span class="n">A</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>  <span class="c1">// same as decltype(A)::const_reference crow0 = *cbegin(A);</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span>       <span class="n">row1</span> <span class="o">=</span>               <span class="n">A</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">// same as decltype(A)::      reference  row1 =               A [1];</span>
<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">crow1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">A</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">// same as decltype(A)::const_reference crow0 = std::as_const(A)[1];</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If a new value is desired, these (equivalent) options express the intention more explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">decltype</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">::</span><span class="n">value_type</span> <span class="n">row</span> <span class="o">=</span>   <span class="o">*</span><span class="n">begin</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>  <span class="c1">// there is a real copy of the row</span>
                   <span class="k">auto</span> <span class="n">row</span> <span class="o">=</span> <span class="o">+</span> <span class="o">*</span><span class="n">begin</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>  <span class="c1">// there is another copy, note the use of '+' (unary plus)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the examples above all elements are accessed in a nested way, recursively down the dimensions.
To iterate over all the elements regardless of the multidimensional structure the following function can print all the elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Array</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">flat_print</span><span class="p">(</span><span class="n">Array</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ma</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"["</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">ma</span><span class="p">.</span><span class="n">elements</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ma</span><span class="p">.</span><span class="n">elements</span><span class="p">().</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span><span class="p">;});</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"]"</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">recursive_print</span><span class="p">(</span><span class="n">A</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">11.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">34.4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">15.2</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mf">32.4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span></code></pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This feature allows to view the array as a flat sequence using the <code>.elements()</code> range, which also has <code>.begin()</code>/<code>.end()</code> and indexing.
For example array element at indices 1,1 is the same as the element </p>
</div>
<div class="sect2">
<h3 id="pointer_to_subarray"><a class="link" href="#pointer_to_subarray">"Pointer" to subarray</a></h3>
<div class="paragraph">
<p>The library strongly relies on value-sematics, and it doesn&#8217;t entertain the concept of "shallow" copy; however, it supports refenece- and pointer-sematics.</p>
</div>
<div class="paragraph">
<p>Subarrays (e.g., rows in a 2D array) are reference-like objects with a concrete address-like value that identifies them uniquely.
These addresses, which behave like pointers, can be helpful to "mark" subviews; these markers can be copied and stored in arrays.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">A</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">});</span>

<span class="k">auto</span> <span class="n">row2_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// A[2] is a row of A (not an element)</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">row2_ptr</span> <span class="o">==</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>A[2]</code> above is technically a C temporary object, and therefore it doesn't have a C address (taking <code>std::addressof</code> gives a compilation error).
However, in the library&#8217;s abstraction, <code>A[2]</code> references an existing part of the original array, i.e. it is a "library reference", whose "library address" can be obtained with the <code>&amp;</code> operator. 
The case is an illustration that, in the library, operator <code>&amp;</code> is, for subarrays, different than the <code>std::addressof</code> operator; the latter may not be defined and even not compile for some expressions.</p>
</div>
<div class="paragraph">
<p>Comparing these markers/pointers with different provenance, i.e., originating from different arrays, is generally undefined.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="indexing"><a class="link" href="#indexing">Indexing</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Arrays provide random access to elements or subviews.
Many algorithms on arrays are oriented to linear algebra,
which are ubiquitously implemented in terms of multidimensional index access.</p>
</div>
<div class="paragraph">
<p>Iterator access and index access are two alternatives for accessing elements.
For example <code>*(begin(A) + n)</code> and <code>A[n]</code> are equivalent
and the range defined by the pair <code>begin(A), end(A)</code> is equivalent to <code>A(extension(A))</code> and, in turn, to <code>A()</code> (even for a multidimensional array, <code>D &gt; 1</code>).
The syntax can be combined in arbitrary ways, for example <code>*begin(A[n])</code> is equivalent to <code>A[n][0]</code>.</p>
</div>
<div class="sect2">
<h3 id="element_access_and_partial_access"><a class="link" href="#element_access_and_partial_access">Element access and partial access</a></h3>
<div class="paragraph">
<p>Index access mimics that of C-fixed sizes arrays. 
For example, a 2-dimensional array will access to an element by specifying two indices <code>A[1][2]</code>,
which can be used for direct write and read operations; 
while <em>partial</em> index arguments <code>A[1]</code> generate a view 1-dimensional object (a reference).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">A</span>        <span class="c1">// is a 2D value array</span>
<span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>     <span class="c1">// is a 1D "reference"/"view" array</span>
<span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">// is a an element reference, zero-D</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Transpositions are also multidimensional arrays <em>views</em> in which the index are <strong>logically</strong> rearranged, for example <code>rotated(m)[2][3][1] == m[1][2][3]</code>.
(<code>rotated</code>/<code>unrotated</code> refers to the fact that the logical <em>indices</em> are rotated to the left/right.)</p>
</div>
<div class="paragraph">
<p>As an illustration of an algorithm based on index access (as opposed to iterators),
this example code implements Gauss Jordan Elimination without pivoting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Matrix</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Vector</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">gj_solve</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="n">Vector</span><span class="o">&amp;&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/=</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">Asize</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">Asize</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">Ar</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
		<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">Arr</span> <span class="o">=</span> <span class="n">Ar</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">Asize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span><span class="n">Ar</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/=</span> <span class="n">Arr</span><span class="p">;}</span>
		<span class="k">auto</span> <span class="k">const</span> <span class="n">yr</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">/=</span> <span class="n">Arr</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r2</span> <span class="o">!=</span> <span class="n">Asize</span><span class="p">;</span> <span class="o">++</span><span class="n">r2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">Ar2</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">r2</span><span class="p">];</span>
			<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Ar2r</span> <span class="o">=</span> <span class="n">Ar2</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>  <span class="c1">// auto&amp;&amp; Ar = A[r];</span>
			<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">Asize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span><span class="n">Ar2</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-=</span> <span class="n">Ar2r</span><span class="o">*</span><span class="n">Ar</span><span class="p">[</span><span class="n">c</span><span class="p">];}</span>
			<span class="n">y</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">Ar2r</span><span class="o">*</span><span class="n">yr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Asize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">yr</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">r2</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">r2</span><span class="p">)</span> <span class="p">{</span><span class="n">y</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">yr</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">r2</span><span class="p">][</span><span class="n">r</span><span class="p">];}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function can be applied to a <code>multi::array</code> container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{{</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.0</span><span class="p">},{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">},{</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">}};</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">};</span>  <span class="c1">// (M); assert(y.size() == M); iota(y.begin(), y.end(), 3.1);</span>
<span class="n">gj_solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and also to a combination of <code>MultiArrayView</code>-type objects (including standard vectors):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">6000</span><span class="p">,</span> <span class="mi">7000</span><span class="p">});</span> <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">data_elements</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">data_elements</span><span class="p">()</span> <span class="o">+</span> <span class="n">A</span><span class="p">.</span><span class="n">num_elements</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span> <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">y</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">);</span>  <span class="c1">// could be also a multi::array&lt;double, 1&gt; y({3000});</span>
<span class="n">gj_solve</span><span class="p">(</span><span class="n">A</span><span class="p">({</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3000</span><span class="p">}),</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="slices_and_strides"><a class="link" href="#slices_and_strides">Slices and strides</a></h3>
<div class="paragraph">
<p>Given an array, a slice in the first dimension can be taken with the <code>sliced</code> function. 
<code>sliced</code> takes two arguments, the first index of the slice and the last index (not included) of the slice. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">});</span>  <span class="c1">// A is a value</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">sizes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">sizes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">);</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">A_sliced</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">sliced</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// {{d2D[1], d2D[2]}}</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A_sliced</span><span class="p">.</span><span class="n">sizes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A_sliced</span><span class="p">.</span><span class="n">sizes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The number of rows in the sliced matrix is 2 because we took only two rows, row 1 and row 2 (row 3 is excluded).</p>
</div>
<div class="paragraph">
<p>In the same way a strided view of the original array can be taken with the <code>strided</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">d2D_strided</span> <span class="o">=</span> <span class="n">d2D</span><span class="p">.</span><span class="n">strided</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// {{ d2D[0], d2D[1] }};</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">d2D_strided</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="n">and</span> <span class="n">d2D_strided</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the number of rows is 2 because, out of the 4 original rows we took one every two.</p>
</div>
<div class="paragraph">
<p>Operations can be combined in a single line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">d2D_slicedstrided</span> <span class="o">=</span> <span class="n">d2D</span><span class="p">.</span><span class="n">sliced</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="n">strided</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// {{ d2D[1] }};</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d2D_slicedstrided</span><span class="p">.</span><span class="n">sizes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d2D_slicedstrided</span><span class="p">.</span><span class="n">sizes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience, <code>A.sliced(a, b, c)</code> is the same as <code>A.sliced(a, b).strided(c)</code>.</p>
</div>
<div class="paragraph">
<p>By combining <code>rotated</code>, <code>sliced</code> and <code>strided</code> one can take sub arrays at any dimension index.
For example in a two dimensional array one can take a subset of columns by defining.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">subA</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">rotated</span><span class="p">().</span><span class="n">sliced</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="n">strided</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">unrotated</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Other notations are available, for example this is equivalent to <code>A(multi::_ , {1, 3, /<strong>every</strong>/2})</code> or <code><sub>(</sub>A)({1, 3, 2})</code>.
The <code>rotated/strided/sliced/rotated</code> and combinations of them provides the most control over the subview operations.</p>
</div>
<div class="paragraph">
<p>Blocks (slices) in multidimensions can be obtained by pure index notation using parentheses <code>()</code> (<code>.operator()</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span>        <span class="n">A</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">});</span>  <span class="c1">// 2D value array</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span>      <span class="n">A_block1</span> <span class="o">=</span> <span class="n">A</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">});</span>  <span class="c1">// 2D subarray reference (modifiable)</span>
<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">A_block2</span> <span class="o">=</span> <span class="n">A</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">});</span>  <span class="c1">// 2D subarray reference (non-modifiable)</span>

<span class="k">auto</span>        <span class="n">A_block3</span> <span class="o">=</span> <span class="n">A</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">});</span>  <span class="c1">// works but it can be confusing, use `auto&amp;&amp;` instead</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes copies are necessary, specifically from a subarray block, this can be done by constructing a new array. 
The value array can be deduced by using <code>auto</code> and the <code>decay</code> member, which in turn is equivalent to the prefix <code>+</code> operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">block_value_1</span> <span class="o">=</span>   <span class="n">A</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>        <span class="p">;</span>
<span class="k">auto</span>                    <span class="n">block_value_2</span> <span class="o">=</span>   <span class="n">A</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">}).</span><span class="n">decay</span><span class="p">();</span>
<span class="k">auto</span>                    <span class="n">block_value_3</span> <span class="o">=</span> <span class="o">+</span> <span class="n">A</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>        <span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Any parenthesis argument can be either a range (with or without stride) or an index. 
Range argument can be substituted by <code>multi::all</code> to obtain the whole range.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conversions"><a class="link" href="#conversions">Conversions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Conversion between arrays of distinct types is possible if the underlying elements allow it.
The result is as if elements are converted one by one; array sizes (extensions) are preserved.
Allowed conversions can be implicit or explicit and reflect the behavior of the element types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// implicit conversions from real to complex is allowed ...</span>
<span class="kt">double</span>                  <span class="n">d</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>     <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>                  <span class="n">z</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
<span class="c1">// ... therefore it is also allowed from array of reals to arrays of complex</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">D</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">});</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span>
<span class="c1">// (implicit or explicit) conversions from real to complex are disallowed (compilation error)</span>
<span class="c1">// multi::array&lt;double, 2&gt; D = Z;  // or D{Z};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another case is illustrated by <code>std::complex&lt;float&gt;</code> and <code>std::complex&lt;double&gt;</code>; 
in one direction, the conversion can be implicit, while in the other, it can only be explicit.
This behavior is reflected in the corresponding arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span>  <span class="n">C</span><span class="p">;</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>  <span class="c1">// implicit conversion ok</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span>  <span class="n">C2</span><span class="p">{</span><span class="n">Z</span><span class="p">};</span>  <span class="c1">// explicit conversion is allowed</span>
<span class="c1">// multi::array&lt;std::complex&lt;float&gt;&gt;  C3 = Z;  // implicit conversion is disallowed (compilation error)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Implicit conversions are generally considered harmful, but inconsistent conversions are worst; therefore, the library allows them when appropriate.
The main drawback of implicit conversions in this context is that they might incur unexpected (e.g. costly) data conversions when passing arguments to functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">Z</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="p">...</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">D</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">});</span>
<span class="n">fun</span><span class="p">(</span><span class="n">D</span><span class="p">);</span>  <span class="c1">// real elements are converted to complex silently here</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In many instances, specially in generic code, it might still be a desirable behavoir.</p>
</div>
<div class="paragraph">
<p>To prevent implicit conversions, use element types with no implicit conversions when possible.</p>
</div>
<div class="paragraph">
<p>Finally, arrays of unrelated element types are prevented from producing direct conversions, resulting in compilation errors.
Element-wise transformations can be used instead.
For example, to convert an array of integers to an array of text strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}};</span>

	<span class="k">auto</span> <span class="n">to_string</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">e</span><span class="p">);};</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">element_transformed</span><span class="p">(</span><span class="n">to_string</span><span class="p">);</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"4"</span> <span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="const_correctness"><a class="link" href="#const_correctness">Const-correctness</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Const-correctness refers to the property of a program to disallow mutation of certain objects when it is undesired or logically incorrect.
Honoring the const-ness declaration is fundamental not only to avoid bugs and typos but also for thread safety and generic programming.
The library goes to great lengths to ensure const-correctness for the whole or parts of any object.</p>
</div>
<div class="paragraph">
<p>Arrays are resizable, and their elements can be mutated unless declared constant (using the keyword <code>const</code>).</p>
</div>
<div class="paragraph">
<p>A reference array or subarray is never resizable, but its elements are mutable if not declared <code>const</code>.
The design ensures that the const-ness of references and values propagates to subarrays (views) and, ultimately, their elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Array1D</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Array1D</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">coll</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//  *coll.begin() = 99;  // doesn't compile, "assignment of read-only location"</span>

	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">coll</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span><span class="s">", "</span><span class="p">;}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">coll1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span>

	<span class="n">print</span><span class="p">(</span> <span class="n">coll1</span> <span class="p">);</span>  <span class="c1">// prints "0, 8, 15, 47, 11, 42"</span>
	<span class="n">print</span><span class="p">(</span> <span class="n">coll1</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span> <span class="p">);</span>  <span class="c1">// prints "0, 8, 15"</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As a general rule for passing generic arrays as arguments, pass them as <code>Array const&amp;</code> (in the context of <code>template&lt;class Array&gt;</code>);
unless mutation is expected, in which case take arguments as <code>Array&amp;&amp;</code> (note the double ampersand, i.e., universal/forwarding reference).
Analogously, subarrays can be locally <strong>named</strong> into "constant language references" using <code>auto const&amp;</code> and, if mutation is desired, <code>auto&amp;&amp;</code> should be used.
Regular references <code>Array&amp;</code> or <code>auto&amp;</code> in general do not have the expected behavior for views.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Array1D</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">fill_99</span><span class="p">(</span><span class="n">Array1D</span><span class="o">&amp;&amp;</span> <span class="n">coll</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">coll</span><span class="p">)</span> <span class="p">{</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">coll1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span>

	<span class="n">fill_99</span><span class="p">(</span> <span class="n">coll1</span> <span class="p">);</span>
	<span class="n">fill_99</span><span class="p">(</span> <span class="n">coll1</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span> <span class="p">);</span>

	<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">coll1_take3</span> <span class="o">=</span> <span class="n">coll1</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>
	<span class="n">fill_99</span><span class="p">(</span> <span class="n">coll1_take3</span> <span class="p">);</span>

	<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">coll2</span> <span class="o">=</span> <span class="n">coll1</span><span class="p">;</span>
<span class="c1">//  fill_99( coll2 );  // doesn't compile because coll2 is const</span>
<span class="c1">//  fill_99( coll2({0, 3}) );  // similar to coll2 | take(3) doesn't compile</span>

	<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">coll1_take3_const</span> <span class="o">=</span> <span class="n">coll1</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>
<span class="c1">//  fill_99( coll1_take3_const );  // doesn't compile because coll1_take3_const is const</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="compile_time_evaluation_constexpr"><a class="link" href="#compile_time_evaluation_constexpr">Compile-time evaluation (constexpr)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>With certain limitations imposed by the language, arrays can be declared in contexts with compile-time evaluation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">trace</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}};</span>
	<span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">diagonal</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">diagonal</span><span class="p">().</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static_assert</span><span class="p">(</span> <span class="n">trace</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">10</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://godbolt.org/z/Porre3z8s" class="bare">https://godbolt.org/z/Porre3z8s</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="broadcast_infinite_views"><a class="link" href="#broadcast_infinite_views">Broadcast (infinite views)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Broadcasting is a technique by which arrays are reinterpreted as having a higher dimension by repeating elements.
The technique allows the reuse of operations designed for high dimensionality and effectively apply them to arrays of lower dimensionality.
The result is generally an economy in the number of distinct operations that need to be provided in exchange for understanding how and where to exploit the broadcast operations.</p>
</div>
<div class="paragraph">
<p>Broadcasting is popular in array-based languages, such as Julia and NumPy, and the broadcast operation is generally applied automatically to match the dimension expected by the operation and other operation inputs.
The library provides a basic form of broadcasting with certain limitations.</p>
</div>
<div class="paragraph">
<p>Here is an example of an algorithm designed for two 2D arrays to obtain the row-by-row inner product.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">row_by_row_dot</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">A2D</span><span class="p">,</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">B2D</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">results</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">A2D</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A2D</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">B2D</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
		<span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Arow</span><span class="p">,</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Brow</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="n">Arow</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Arow</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">Brow</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);}</span>
	<span class="p">);</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">A</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">{{</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">}};</span>
<span class="k">auto</span> <span class="n">B</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">{{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">},</span> <span class="p">{</span><span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">}};</span>

<span class="k">auto</span> <span class="n">dots</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">({</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()});</span>

<span class="n">row_by_row_dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">dots</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If, for some reason, we want to obtain the inner product against a <em>single</em> right-hand vector instead of several (a single 1D array of two elements), we would need to (re)write the function (or copy the repeated vector into the 2D <code>B</code> array, which is not ideal.)
Broadcasting can help reuse the same function without changes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">};</span>

<span class="n">row_by_row_dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">(),</span> <span class="n">dots</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The alternative, not using broadcast, is to write a very similar function,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">row_fixed_dot</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">A2D</span><span class="p">,</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b1D</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">results</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">A2D</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A2D</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
		<span class="p">[</span><span class="o">&amp;</span><span class="n">b1D</span><span class="p">](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Arow</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="n">Arow</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Arow</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">b1D</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);}</span>
	<span class="p">);</span>
<span class="p">};</span>

<span class="n">row_fixed_dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dots3</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(<a href="https://godbolt.org/z/9ndvfKqhc" class="bare">https://godbolt.org/z/9ndvfKqhc</a>)</p>
</div>
<div class="paragraph">
<p>Broadcasted arrays do not behave like normal array views in several aspects:
First, broadcasted arrays are infinite in the broadcasted dimension; iteration will never reach the end position, and calling <code>.size()</code> is undefined behavior.
Explicit loops or algorithms that depend on reaching <code>.end()</code> from <code>.begin()</code> will effectively be non-terminating.
Second, these array views are strictly read-only and alias their element addresses, e.g. <code>&amp;b.broadcasted()[1][0] == &amp;b.broadcasted()[2][0]</code> (since internal layouts' strides can be zero).</p>
</div>
<div class="paragraph">
<p>&lt;!-- For illustration purposes only, <code>fill</code> here is replaced by <code>copy</code>; problematic uses are highlighted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="n">fill</span>  <span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">b</span><span class="p">);</span>                                       <span class="c1">// canonical way</span>
<span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">b</span><span class="p">);</span>                                      <span class="c1">// canonical way</span>

<span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>                <span class="c1">// equivalent, using broadcast</span>

<span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>  <span class="c1">// incorrect, undefined behavior, no useful size()</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span>  <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">().</span><span class="n">end</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>   <span class="c1">// incorrect, undefined behavior, non-terminating loop (end is not reacheable)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">();</span>                                                      <span class="c1">// incorrect, undefined behavior, B would be of infinite allocated size</span>
<span class="err">```</span> <span class="o">--&gt;</span>

<span class="n">Unlike</span> <span class="n">in</span> <span class="n">popular</span> <span class="n">languages</span><span class="p">,</span> <span class="n">broadcasting</span> <span class="n">is</span> <span class="n">not</span> <span class="n">automatic</span> <span class="n">in</span> <span class="n">the</span> <span class="n">library</span> <span class="n">and</span> <span class="n">is</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">the</span> <span class="n">leading</span> <span class="n">dimension</span> <span class="n">only</span><span class="p">,</span> <span class="n">one</span> <span class="n">dimension</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span><span class="p">.</span>
<span class="n">Broadcasting</span> <span class="n">in</span> <span class="n">non</span><span class="o">-</span><span class="n">leading</span> <span class="n">dimensions</span> <span class="n">can</span> <span class="n">be</span> <span class="n">achieved</span> <span class="n">by</span> <span class="n">transpositions</span> <span class="n">and</span> <span class="n">index</span> <span class="n">rotation</span><span class="p">.</span>

<span class="n">Abuse</span> <span class="n">of</span> <span class="n">broadcast</span> <span class="n">can</span> <span class="n">make</span> <span class="n">it</span> <span class="n">harder</span> <span class="n">to</span> <span class="n">reason</span> <span class="n">about</span> <span class="n">operations</span><span class="p">;</span>
<span class="n">its</span> <span class="n">primary</span> <span class="n">use</span> <span class="n">is</span> <span class="n">to</span> <span class="n">reuse</span> <span class="n">existing</span> <span class="n">efficient</span> <span class="n">implementations</span> <span class="n">of</span> <span class="n">algorithms</span> <span class="n">when</span> <span class="n">implementations</span> <span class="k">for</span> <span class="n">a</span> <span class="n">specific</span> <span class="n">lower</span> <span class="n">dimensions</span> <span class="n">are</span> <span class="n">not</span> <span class="n">available</span><span class="p">.</span>
<span class="n">These</span> <span class="n">algorithms</span> <span class="n">need</span> <span class="n">to</span> <span class="n">be</span> <span class="n">compatible</span> <span class="n">with</span> <span class="n">broadcasted</span> <span class="nf">views</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span> <span class="n">no</span> <span class="k">explicit</span> <span class="n">use</span> <span class="n">of</span> <span class="err">`</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="err">`</span> <span class="n">or</span> <span class="n">infinite</span> <span class="n">loops</span> <span class="n">stemming</span> <span class="n">from</span> <span class="n">problematic</span> <span class="n">use</span> <span class="n">of</span> <span class="err">`</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">/</span><span class="n">end</span><span class="p">()</span><span class="err">`</span><span class="p">.)</span>

<span class="p">(</span><span class="n">In</span> <span class="n">STL</span><span class="p">,</span> <span class="n">algorithms</span> <span class="n">ending</span> <span class="n">with</span> <span class="err">`</span><span class="n">_n</span><span class="err">`</span> <span class="n">should</span> <span class="n">be</span> <span class="n">friendly</span> <span class="n">to</span> <span class="n">broadcast</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">unfortunately</span> <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="err">`</span> <span class="n">is</span> <span class="n">sometimes</span> <span class="n">internally</span> <span class="n">implemented</span> <span class="n">in</span> <span class="n">terms</span> <span class="n">of</span> <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="err">`</span> <span class="n">causing</span> <span class="n">a</span> <span class="n">problematic</span> <span class="n">iterator</span> <span class="n">arithmetic</span> <span class="n">on</span> <span class="n">infinite</span> <span class="n">arrays</span><span class="p">.</span>
<span class="n">NB</span><span class="o">:</span> <span class="err">`</span><span class="n">thrust</span><span class="o">::</span><span class="n">copy_n</span><span class="err">`</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="n">instead</span><span class="p">.)</span>

<span class="n">As</span> <span class="n">a</span> <span class="k">final</span> <span class="n">example</span><span class="p">,</span> <span class="n">consider</span> <span class="n">a</span> <span class="n">function</span> <span class="n">that</span> <span class="n">computes</span> <span class="n">the</span> <span class="n">elements</span><span class="o">-</span><span class="n">by</span><span class="o">-</span><span class="n">element</span> <span class="n">product</span> <span class="n">of</span> <span class="n">two</span> <span class="mi">2</span><span class="n">D</span> <span class="n">arrays</span><span class="p">,</span>

<span class="err">```</span><span class="n">cpp</span>
<span class="k">auto</span> <span class="n">hadamard</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">B</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">C</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">auto</span> <span class="k">const</span> <span class="p">[</span><span class="n">is</span><span class="p">,</span> <span class="n">js</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">extensions</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">is</span><span class="p">)</span> <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">:</span> <span class="n">js</span><span class="p">)</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As it is, this function can be reused to calculate the outer product of two 1D arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">outer</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">C</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">hadamard</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">()),</span> <span class="n">b</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(<a href="https://godbolt.org/z/5o95qGdKz" class="bare">https://godbolt.org/z/5o95qGdKz</a>)</p>
</div>
<div class="paragraph">
<p>Note that the function <code>hadamard</code>, acting on 2D arrays, doesn&#8217;t use the undefined (infinite) sizes (second dimension of <code>A</code> and first dimension of <code>B</code>).</p>
</div>
<div class="paragraph">
<p>NB: A zero-dimensional broadcasts into a one-dimensional.
Zero-dimensional arrays can contain, at most, one element; and after a broadcast, it can represent an infinite sequence of such element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">single</span><span class="p">{</span><span class="mi">7</span><span class="p">};</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">sevens</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>

<span class="n">single</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">().</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">sevens</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sevens</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">single</span><span class="p">.</span><span class="n">broadcasted</span><span class="p">().</span><span class="n">begin</span><span class="p">())</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(<a href="https://godbolt.org/z/nnxjsrvM1" class="bare">https://godbolt.org/z/nnxjsrvM1</a>)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="uninitialized_vs_initialized_elements"><a class="link" href="#uninitialized_vs_initialized_elements">Uninitialized vs. initialized elements</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>If available, the library can take advantage of trivial initialization for the specific element type.
These types can be primitive or user-defined and come with "trivial default constructors". In simple terms, these constructors are not specified and do nothing, not even set values.</p>
</div>
<div class="paragraph">
<p>When used in the stack, these types can be declared with no initialization (e.g., <code>double x;</code>, the initial value is not well defined or partially-formed) or with initialization (e.g., <code>double x{};</code>, same as <code>double x = 0.0;</code>).
Analogously, <code>multi::array</code> does not initialize individual elements of this kind of type unless specified.</p>
</div>
<div class="paragraph">
<p>For example, after this construction of the array, the values of the six elements of this array are unspecified (partially-formed).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A2</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>  <span class="c1">// A2 elements have unspecified value</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>No behavior of the program should depend on these values. 
(Address sanitizers and memory checkers can detect use of uninitialized values.)
This design is a slight departure from the STL&#8217;s design, which [eagerly initializes elements in containers](<a href="https://lemire.me/blog/2012/06/20/do-not-waste-time-with-stl-vectors/" class="bare">https://lemire.me/blog/2012/06/20/do-not-waste-time-with-stl-vectors/</a>).</p>
</div>
<div class="paragraph">
<p>If trivial construction is unavailable, the library uses the default initialization.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A2</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>  <span class="c1">// A2 elements have specified value, the empty value std::string{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For types that afford this partially formed states, elements can be later specified via assignment or assigning algorithms (e.g., copy or transform destination).</p>
</div>
<div class="paragraph">
<p>Initialization can be enforced by passing a single value argument after the extensions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A2</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// generically multi::array&lt;T, 2&gt;({2, 3}, T{}); or multi::array&lt;T, 2&gt;({2, 3}, {})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This design is particularly advantageous for <strong>numeric</strong> types for which external low-level libraries can fill values.
(or when data sits in GPUs, where the initialization step would require an expensive kernel launch and subsequent synchronization).</p>
</div>
<div class="paragraph">
<p>Unfortunately, regarding the numeric types, STL&#8217;s <code>std::complex&lt;double&gt;</code> was standardized as not-trivially constructible.
A workaround built-in this library is available by forcing a particular flag on the client code in global scope, for example, immediately after including the library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;multi/array.hpp&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="kr">inline</span> <span class="k">constexpr</span>
<span class="kt">bool</span> <span class="n">multi</span><span class="o">::</span><span class="n">force_element_trivial_default_construction</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// should be defined as early as possible</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this line, <code>std::complex&lt;double&gt;</code> elements inside arrays will be left uninitialized unless a value is specified.
The rule will only apply to this library&#8217;s containers (<code>multi::array</code>, etc), and not to other containers (such as <code>std::vector</code>) or individual <code>std::complex</code> variables.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type_requirements"><a class="link" href="#type_requirements">Type Requirements</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The library design tries to impose the minimum possible requirements over the types that parameterize the arrays.
Array operations assume that the contained type (element type) are regular (i.e. different element represent disjoint entities that behave like values).
Pointer-like random access types can be used as substitutes of built-in pointers.
(Therefore pointers to special memory and fancy-pointers are supported.)</p>
</div>
<div class="sect2">
<h3 id="linear_sequences_pointers"><a class="link" href="#linear_sequences_pointers">Linear Sequences: Pointers</a></h3>
<div class="paragraph">
<p>An <code>array_ref</code> can reference an arbitrary random access linear sequence (e.g. memory block defined by pointer and size).
This way, any linear sequence (e.g. <code>raw memory</code>, <code>std::vector</code>, <code>std::queue</code>) can be efficiently arranged as a multidimensional array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array_ref</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="n">buffer</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">9.0</span><span class="p">;</span>

<span class="n">assert</span><span class="p">(</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">==</span> <span class="mf">9.0</span> <span class="p">);</span>  <span class="c1">// the target memory is affected</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code>array_ref</code> does not manage the memory associated with it, the reference can be simply dangle if the <code>buffer</code> memory is reallocated (e.g. by vector-<code>resize</code> in this case).</p>
</div>
</div>
<div class="sect2">
<h3 id="special_memory_pointers_and_views"><a class="link" href="#special_memory_pointers_and_views">Special Memory: Pointers and Views</a></h3>
<div class="paragraph">
<p>`array`s manage their memory behind the scenes through allocators, which can be specified at construction.
It can handle special memory, as long as the underlying types behave coherently, these include [fancy pointers](<a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers" class="bare">https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers</a>) (and fancy references).
Associated fancy pointers and fancy reference (if any) are deduced from the allocator types.</p>
</div>
<div class="sect3">
<h4 id="allocators_and_fancy_pointers"><a class="link" href="#allocators_and_fancy_pointers">Allocators and Fancy Pointers</a></h4>
<div class="paragraph">
<p>Specific uses of fancy memory are file-mapped memory or interprocess shared memory.
This example illustrates memory persistency by combining with Boost.Interprocess library. 
The arrays support their allocators and fancy pointers (<code>boost::interprocess::offset_ptr</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;boost/interprocess/managed_mapped_file.hpp&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="p">;</span>
<span class="k">using</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">managed_mapped_file</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">mallocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">manager</span><span class="o">::</span><span class="n">segment_manager</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get_allocator</span><span class="p">(</span><span class="n">manager</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">get_segment_manager</span><span class="p">();}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">auto</span> <span class="n">D</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">marray</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">mallocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="p">{</span>
	<span class="n">manager</span> <span class="n">m</span><span class="p">{</span><span class="n">create_only</span><span class="p">,</span> <span class="s">"mapped_file.bin"</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">};</span>
	<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">arr2d</span> <span class="o">=</span> <span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">construct</span><span class="o">&lt;</span><span class="n">marray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">"arr2d"</span><span class="p">)(</span><span class="n">marray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;::</span><span class="n">extensions_type</span><span class="p">{</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">},</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">get_allocator</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
	<span class="n">arr2d</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">45.001</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// imagine execution restarts here, the file "mapped_file.bin" persists</span>
<span class="p">{</span>
	<span class="n">manager</span> <span class="n">m</span><span class="p">{</span><span class="n">open_only</span><span class="p">,</span> <span class="s">"mapped_file.bin"</span><span class="p">};</span>
	<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">arr2d</span> <span class="o">=</span> <span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="o">&lt;</span><span class="n">marray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">"arr2d"</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">arr2d</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span> <span class="p">);</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">arr2d</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mf">45.001</span> <span class="p">);</span>
	<span class="n">m</span><span class="p">.</span><span class="n">destroy</span><span class="o">&lt;</span><span class="n">marray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">"arr2d"</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>([live](<a href="https://godbolt.org/z/oeTss3s35" class="bare">https://godbolt.org/z/oeTss3s35</a>))</p>
</div>
<div class="paragraph">
<p>(See also, examples of interactions with the CUDA Thrust library to see more uses of special pointer types to handle special memory.)</p>
</div>
</div>
<div class="sect3">
<h4 id="transformed_views"><a class="link" href="#transformed_views">Transformed views</a></h4>
<div class="paragraph">
<p>Another kind of use of the internal pointer-like type is to transform underlying values.
These are useful to create "projections" or "views" of data elements.
In the following example a "transforming pointer" is used to create a conjugated view of the elements.
In combination with a transposed view, it can create a hermitic (transposed-conjugate) view of the matrix (without copying elements).
We can adapt the library type <code>boost::transform_iterator</code> to save coding, but other libraries can be used also.
The hermitized view is read-only, but with additional work, a read-write view can be created (see <code>multi::::hermitized</code> in multi-adaptors).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">conj</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">conj</span><span class="p">(</span><span class="n">c</span><span class="p">);};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">conjr</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">transform_iterator</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">conj</span><span class="p">),</span> <span class="n">T</span><span class="o">*&gt;</span> <span class="p">{</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">As</span><span class="p">&gt;</span> <span class="n">conjr</span><span class="p">(</span><span class="n">As</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">as</span><span class="p">)</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">transform_iterator</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">conj</span><span class="p">),</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">{</span><span class="n">as</span><span class="p">...}</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Array2D</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Complex</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Array2D</span><span class="o">::</span><span class="n">element_type</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">hermitized</span><span class="p">(</span><span class="n">Array2D</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">arr</span>
		<span class="p">.</span><span class="n">transposed</span><span class="p">()</span> <span class="c1">// lazily tranposes the array</span>
		<span class="p">.</span><span class="k">template</span> <span class="n">static_array_cast</span><span class="o">&lt;</span><span class="n">Complex</span><span class="p">,</span> <span class="n">conjr</span><span class="o">&lt;</span><span class="n">Complex</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">conj</span><span class="p">)</span>  <span class="c1">// lazy conjugate elements</span>
	<span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">complex_literals</span><span class="p">;</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mx">2.0i</span><span class="p">,</span>  <span class="mf">3.0</span> <span class="o">+</span>  <span class="mx">4.0i</span><span class="p">},</span>
		<span class="p">{</span> <span class="mf">8.0</span> <span class="o">+</span> <span class="mx">9.0i</span><span class="p">,</span> <span class="mf">10.0</span> <span class="o">+</span> <span class="mx">11.0i</span><span class="p">}</span>
	<span class="p">};</span>

	<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Ah</span> <span class="o">=</span> <span class="n">hermitized</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

	<span class="n">assert</span><span class="p">(</span> <span class="n">Ah</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">conj</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To simplify this boilerplate, the library provides the <code>.element_transformed(F)</code> method that will apply a transformation <code>F</code> to each element of the array.
In this example, the original array is transformed into a transposed array with duplicated elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">},</span>
		<span class="p">{</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">},</span>
	<span class="p">};</span>

	<span class="k">auto</span> <span class="k">const</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">;</span> <span class="p">};</span>

	<span class="k">auto</span> <span class="n">B</span> <span class="o">=</span> <span class="o">+</span> <span class="n">A</span><span class="p">.</span><span class="n">transposed</span><span class="p">().</span><span class="n">element_transformed</span><span class="p">(</span><span class="n">scale</span><span class="p">);</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>([live](<a href="https://godbolt.org/z/TYavYEG1T" class="bare">https://godbolt.org/z/TYavYEG1T</a>))</p>
</div>
<div class="paragraph">
<p>Since <code>element_transformed</code> is a reference-like object (transformed view) to the original data, it is important to understand the semantics of evaluation and possible allocations incurred.
As mentioned in other sections using <code>auto</code> and/or <code>+</code> appropriately can lead to simple and efficient expressions.</p>
</div>
<div class="paragraph">
<p>| Construction    | Allocation of <code>T`s | Initialization (of `T`s) | Evaluation (of `fun</code>) | Notes |
| -------- | ------- | ------- | ------- | ------- |
| <code>multi::array&lt;T, D&gt; const B = A.element_transformed(fun);</code> | Yes        | No  | Yes | Implicit conversion to <code>T</code> if result is different, dimensions must match. B can be mutable.   |
| <code>multi::array&lt;T, D&gt; const B = + A.element_transformed(fun);</code> | Yes (and move, or might allocate twice if types don&#8217;t match)  | No  | Yes | Not recommended | 
| <code>multi::array&lt;T, D&gt; const B{A.element_transformed(fun)};</code> | Yes        | No  | Yes | Explicit conversion to <code>T</code> if result is different, dimensions must match   |
| <code>auto const B = + A.elements_transformed(fun);</code>           | Yes         | No  | Yes | Types and dimension are deduced, result is contiguous, preferred |
| <code>auto const B = A.element_transformed(fun);</code>               | No         | No  | No (delayed) | Result is effective a reference, may dangle with <code>A</code>, usually <code>const</code>, not recommended   |
| <code>auto const&amp; B = A.elements_transformed(fun);</code>           | No         | No  | No (delayed) | Result is effective a reference, may dangle with <code>A</code>. Preferred way.  |
| <code>multi::array&lt;T, D&gt; B(A.extensions()); B = A.element_transformed(fun);</code>           | Yes         | Yes (during construction)  | Yes | "Two-step" construction. <code>B</code> is mutable. Not recommended  |</p>
</div>
<div class="paragraph">
<p>| Assigment    | Allocation of <code>T`s | Initialization (of `T`s) | Evaluation (of `fun</code>) | Notes |
| -------- | ------- | ------- | ------- | ------- |
| <code>B = A.elements_transformed(fun);</code>           | No, if sizes match | Possibly (when <code>B</code> was initialized)  | Yes | <code>B</code> can&#8217;t be declared <code>const</code>, it can be a writable subarray, preferred  |
| <code>B = + A.elements_transformed(fun);</code>           | Yes | Possibly (when <code>B</code> was initialized)  | Yes | Not recommended. |</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fundamental_types_and_concepts"><a class="link" href="#fundamental_types_and_concepts">Fundamental types and concepts</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The library interface presents several closely related C++ types (classes) representing arrays.
The fundamental types represent multidimensional containers (called <code>array</code>), references that can refer to subsets of these containers (called <code>subarray</code>), and iterators.
In addition, there are other classes for advanced uses, such as multidimensional views of existing buffers (called <code>array_ref</code>) and non-resizable owning containers (called <code>static_array</code>).</p>
</div>
<div class="paragraph">
<p>When using the library, it is simpler to start from <code>array</code>, and other types are rarely explicitly used, especially if using <code>auto</code>;
however, it is convenient for documentation to present the classes in a different order since the classes <code>subarray</code>, <code>array_ref</code>, <code>static_array</code>, and <code>array</code> have an <strong>is-a</strong> relationship (from left to right). 
For example, <code>array_ref</code> has all the methods available to <code>subarray</code>, and <code>array</code> has all the operations of <code>array_ref</code>.
Furthermore, the <strong>is-a</strong> relationship is implemented through C++ public inheritance, so, for example, a reference of type <code>subarray&lt;T, D&gt;&amp;</code> can refer to a variable of type <code>array&lt;T, D&gt;</code>.</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;class &lt;code&gt;multi::subarray&lt;T, D, P = T* &gt;&lt;/code&gt;&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>A subarray-reference is part (or a whole) of another larger array.
It is important to understand that <code>subarray`s have referential semantics, their elements are not independent of the values of the larger arrays they are part of.
An instance of this class represents a subarray with elements of type `T</code> and dimensionality <code>D</code>, stored in memory described by the pointer type <code>P</code>.
(<code>T</code>, <code>D</code>, and <code>P</code> initials are used in this sense across the documentation.)</p>
</div>
<div class="paragraph">
<p>Instances of this class have reference semantics and behave like "language references" as much as possible.
As references, they cannot be rebinded or resized; assignments are always "deep".
They are characterized by a size that does not change in the lifetime of the reference.
They are usually the result of indexing over other `multi::subarray`s and `multi::array`s objects, typically of higher dimensions;
therefore, the library doesn&#8217;t expose constructors for this class.
The whole object can be invalidated if the original array is destroyed.</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Member types&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| <code>subarray::</code>      | Description               |
|---                |---                        |
| <code>value_type</code>      | <code>multi::array&lt;T, D - 1, P &gt;</code> or, for <code>D == 1</code>, <code>iterator_traits&lt;P&gt;::value_type</code> (usually <code>T</code>)   
| <code>reference</code>       | <code>multi::subarray&lt;T, D-1, P &gt;</code> or, for <code>D == 1</code>, <code>pointer_traits&lt;P&gt;::reference</code> (usually <code>T&amp;</code>) 
| <code>const_reference</code> | <code>multi::const_subarray&lt;T, D-1, P &gt;</code> or, for <code>D == 1</code>, <code>pointer_traits&lt;P&gt;::rebind&lt;T const&gt;::reference</code> (usually <code>T const&amp;</code>)
| <code>index</code>           | indexing type in the leading dimension (usually <code>std::diffptr_t</code>)
| <code>size_type</code>       | describe size (number of subarrays) in the leading dimension (signed version of pointer size type, usually <code>std::diffptr_t</code>)
| <code>index_range</code>     | describe ranges of indices, constructible from braced indices types or from an <code>extension_type</code>. Can be continuous (e.g. <code>{2, 14}</code>) or strided (e.g. <code>{2, 14, /<strong>every</strong>/ 3}</code>)
| <code>extesion_type</code>   | describe a contiguous range of indices, constructible from braced index (e.g. <code>{0, 10}</code>) or from a single integer size (e.g. 10, equivalent to <code>{0, 10}</code>). 
| <code>difference_type</code> | describe index differences in leading dimension (signed version of pointer size type, usually <code>std::diffptr_t</code>)
| <code>pointer</code>         | <code>multi::subarray_ptr&lt;T, D-1, P &gt; or, for `D == 1, `P</code> (usually <code>T*</code>)
| <code>const_pointer</code>   | <code>multi::const_subarray_ptr&lt;T, D-1, P &gt;</code> or, for <code>D == 1, `pointer_traits&lt;P&gt;::rebind&lt;T const&gt;</code> (usually <code>T const*</code>)
| <code>iterator</code>        | <code>multi::array_iterator_t&lt;T, D-1, P &gt;</code>
| <code>const_iterator</code>  | <code>multi::const_array_iterator_t&lt;T, D-1, P &gt;</code></p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Special member functions&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| <code>subarray::</code>      | Description |
|---                |--- |
| (constructors)    | not exposed; copy constructor is not available since the instances are not copyable; destructors are trivial since it doesn&#8217;t own the elements |
| <code>operator=</code>       | assigns the elements from the source; the sizes must match |</p>
</div>
<div class="paragraph">
<p>It is important to note that assignments in this library are always "deep," and reference-like types cannot be rebound after construction.
(Reference-like types have corresponding pointer-like types that provide an extra level of indirection and can be rebound (just like language pointers);
these types are <code>multi::array_ptr</code> and <code>multi::subarray_ptr</code> corresponding to <code>multi::array_ref</code> and <code>multi::subarray</code> respectively.)</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Relational functions&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| Relational fuctions       |    |
|---                        |--- |
| <code>operator==</code>/<code>operator!=</code> | Tells if elements of two <code>subarray</code> are equal (and if extensions of the subarrays are the same)
| <code>operator&lt;</code>/<code>operator&#8656;</code>  | Less-than/less-or-equal      lexicographical comparison (requires elements to be comparable)
| <code>operator&gt;</code>/<code>operator&gt;=</code>  | Greater-than/grater-or-equal lexicographical comparison (requires elements to be comparable)</p>
</div>
<div class="paragraph">
<p>It is important to note that, in this library, comparisons are always "deep".
Lexicographical order is defined recursively, starting from the first dimension index and from left to right.
For example, <code>A &lt; B</code> if <code>A[0] &lt; B[0]</code>, or <code>A[0] == B[0]</code> and <code>A[1] &lt; B[1]</code>, or &#8230;&#8203;, etc.
Lexicographical order applies naturally if the extensions of <code>A</code> and <code>B</code> are different; however, their dimensionalities must match.
(See sort examples).</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Shape access&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| Shape             |    |
|---                |--- |
| <code>sizes</code>           | returns a tuple with the sizes in each dimension
| <code>extensions</code>      | returns a tuple with the extensions in each dimension
| <code>size</code>            | returns the number of subarrays contained in the first dimension |
| <code>extension</code>       | returns a contiguous index range describing the set of valid indices
| <code>num_elements</code>    | returns the total number of elements</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Element access&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| Element access    |    |
|---                |--- |
|<code>operator[]</code>       | access specified element by index (single argument), returns a <code>reference</code> (see above), for <code>D &gt; 1</code> it can be used recursively |
|<code>front</code>            | access first element (undefined result if array is empty). Takes no argument.
|<code>back</code>             | accessÂ last element  (undefined result ifÂ array is empty). Takes no argument.
|<code>operator()</code>       | When used with zero arguments, it returns a <code>subarray</code> representing the whole array. When used with one argument, access a specified element by index (return a <code>reference</code>) or by range (return a <code>subarray</code> of equal dimension). For more than one, arguments are positional and reproduce expected array access syntax from Fortran or Matlab: |</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subarray::operator()(i, j, k, &#8230;&#8203;)</code>, as in <code>S(i, j, k)</code> for indices <code>i</code>, <code>j</code>, <code>k</code> is a synonym for <code>A[i][j][k]</code>, the number of indices can be lower than the total dimension (e.g., <code>S</code> can be 4D).
Each index argument lowers the dimension by one.</p>
</li>
<li>
<p><code>subarray::operator()(ii, jj, kk)</code>, the arguments can be indices or ranges of indices (<code>index_range</code> member type).
This function allows positional-aware ranges.
Each index argument lowers the rank by one.
A special range is given by <code>multi::_</code>, which means "the whole range" (also spelled <code>multi::all</code>).
For example, if <code>S</code> is a 3D of sizes 10-by-10-by-10, <code>S(3, {2, 8}, {3, 5})</code> gives a reference to a 2D array where the first index is fixed at 3, with sizes 6-by-2 referring the subblock in the second and third dimension.
Note that <code>S(3, {2, 8}, {3, 5})</code> (6-by-2) is not equivalent to <code>S[3]({2, 8})({3, 5})</code> (2-by-10).</p>
</li>
<li>
<p><code>operator()()</code> (no arguments) gives the same array but always as a subarray type (for consistency), <code>S()</code> is equivalent to <code>S(S.extension())</code> and, in turn to <code>S(multi::_)</code> or <code>S(multi::all)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Structure access&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| Structure access  | (Generally used for interfacing with C-libraries)   |
|---                |--- |
| <code>base</code>            | direct access to underlying memory pointer (<code>S[i][j]&#8230;&#8203; == S.base() + std::get&lt;0&gt;(S.strides())*i + std::get&lt;1&gt;(S.strides())*j + &#8230;&#8203;</code>)
| <code>stride</code>          | return the stride value of the leading dimension, e.g <code>(&amp;A[1][0][0]&#8230;&#8203; - &amp;A[0][0]&#8230;&#8203;)</code>
| <code>strides</code>         | returns a tuple with the strides defining the internal layout
| <code>layout</code>          | returns a single layout object with stride and size information |</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Iterators&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| Iterators         |    |
|---                |--- |
| <code>begin/cbegin</code>    | returns (const) iterator to the beginning
| <code>end/cend</code>        | returns (const) iterator to the end</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;Subarray/array generators&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>| Subarray generators   | (these operations do not copy elements or allocate)    |
|---                    |---  |
| <code>broadcasted</code>         | returns a view of dimensionality <code>D + 1</code> obtained by infinite repetition of the original array. (This returns a special kind of subarray with a degenerate layout and no size operation. Takes no argument.)
| <code>dropped</code>             | (takes one integer argument <code>n</code>) returns a subarray with the first n-elements (in the first dimension) dropped from the original subarray. This doesn&#8217;t remove or destroy elements or resize the original array 
| <code>element_transformed</code> | creates a view of the array, where each element is transformed according to a function (first and only argument) |
| <code>elements</code>            | a flatted view of all the elements rearranged canonically. <code>A.elements()[0] &#8594; A[0][0]</code>, <code>A.elements()[1] &#8594; A[0][1]</code>, etc. The type of the result is not a subarray but a special kind of range. Takes no argument.
| <code>rotated/unrotated</code>   | a view (<code>subarray</code>) of the original array with indices (un)rotated from right to left (left to right), for <code>D = 1</code> returns the same <code>subarray</code>. For given <code>i</code>, <code>j</code>, <code>k</code>, <code>A[i][j][k]</code> gives the same element as <code>A.rotated()[j][k][i]</code> and, in turn the same as <code>A.unrotated()[k][i][j])</code>. Preserves dimension. The function is cyclic; <code>D</code> applications will give the original view. Takes no argument. |
| <code>transposed</code> (same as <code>operator~</code>) | a view (<code>subarray</code>) of the original array with the first two indices exchanged, only available for <code>D &gt; 1</code>; for <code>D = 2</code>, <code>rotated</code>, <code>unrotated</code> and <code>transposed</code> give same view. Takes no argument.  |
| <code>sliced</code>              | (takes two index arguments <code>a</code> and <code>b</code>) returns a subarray with elements from index <code>a</code> to index <code>b</code> (non-inclusive) <code>{S[a], &#8230;&#8203; S[b-1]}</code>. Preserves the dimension.
| <code>strided</code>             | (takes one integer argument <code>s</code>) returns a subarray skipping <code>s</code> elements. Preserves the dimension.</p>
</div>
<div class="paragraph">
<p>| Creating views by pointer manipulation     |     |
|---                                         |---  |
| <code>static_array_cast&lt;T2, P2 = T2*&gt;(args&#8230;&#8203;)</code> | produces a view where the underlying pointer constructed by <code>P2{A.base(), args&#8230;&#8203;}</code>. Usually, <code>args&#8230;&#8203;</code> is empty. Non-empty arguments are useful for stateful fancy pointers, such as transformer iterators.
| <code>reinterpret_cast_array&lt;T2&gt;</code>               | underlying elements are reinterpreted as type T2, element sizes (<code>sizeof</code>) have to be equal; <code>reinterpret_cast_array&lt;T2&gt;(n)</code> produces a view where the underlying elements are interpreted as an array of <code>n</code> elements of type <code>T2</code>.</p>
</div>
<div class="paragraph">
<p>| Creating arrays                     |     |
|---                                  |---  |
| <code>decay</code> (same as prefix unary <code>operator+</code>) | creates a concrete independent <code>array</code> with the same dimension and elements as the view. Usually used to force a value type (and forcing a copy of the elements) and avoid the propagation of a reference type in combination with <code>auto</code> (e.g., <code>auto A2_copy = + A[2];</code>).</p>
</div>
<div class="paragraph">
<p>A reference <code>subarray</code> can be invalidated when its origin array is invalidated or destroyed.
For example, if the <code>array</code> from which it originates is destroyed or resized.</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;
&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;class &lt;code&gt;multi::array_ref&lt;T, D, P = T* &gt;&lt;/code&gt;&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>A <em>D</em>-dimensional view of the contiguous pre-existing memory buffer.
This class doesn&#8217;t manage the elements it contains, and it has reference semantics (it can&#8217;t be rebound, assignments are deep, and have the same size restrictions as <code>subarray</code>)</p>
</div>
<div class="paragraph">
<p>Since <code>array_ref</code> is-a <code>subarray</code>, it inherits all the class methods and types described before and, in addition, it defines these members below.</p>
</div>
<div class="paragraph">
<p>| Member types      | same as for <code>subarray</code> |
|---                |---                        |</p>
</div>
<div class="paragraph">
<p>| Member functions  | same as for <code>subarray</code> plus &#8230;&#8203; |
|---                |--- |
| (constructors)    | <code>array_ref::array_ref({e1, e2, &#8230;&#8203;}, p)</code> constructs a D-dimensional view of the contiguous range starting at p and ending at least after the size size of the multidimensional array (product of sizes). The default constructor and copy constructor are not exposed. Destructor is trivial since elements are not owned or managed. |</p>
</div>
<div class="paragraph">
<p>| Element access    | same as for <code>subarray</code> |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Structure access  | same as for <code>subarray</code> |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Iterators         | same as for <code>subarray</code>   |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Capacity          | same as for <code>subarray</code>   |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Creating views    | same as for <code>subarray</code>  |
|---                |---  |</p>
</div>
<div class="paragraph">
<p>| Creating arrays   | same as for <code>subarray</code>  |
|---                |---  |</p>
</div>
<div class="paragraph">
<p>| Relational functions   |  same as for <code>subarray</code>  |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>An <code>array_ref</code> can be invalidated if the original buffer is deallocated.</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;class &lt;code&gt;multi::static_array&lt;T, D, Alloc = std::allocator&lt;T&gt; &gt;&lt;/code&gt;&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>A <em>D</em>-dimensional array that manages an internal memory buffer.
This class owns the elements it contains; it has restricted value semantics because assignments are restricted to sources with equal sizes.
Memory is requested by an allocator of type Alloc (standard allocator by default).
It supports stateful and polymorphic allocators, which are the default for the special type <code>multi::pmr::static_array</code>.</p>
</div>
<div class="paragraph">
<p>The main feature of this class is that its iterators, subarrays, and pointers do not get invalidated unless the whole object is destroyed.
In this sense, it is semantically similar to a C-array, except that elements are allocated from the heap.
It can be useful for scoped uses of arrays and multi-threaded programming and to ensure that assignments do not incur allocations.
The C++ coreguiles proposed a similar (albeith one-dimensional) class, called [<code>gsl::dyn_array</code>](<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#gslowner-ownership-pointers" class="bare">http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#gslowner-ownership-pointers</a>).</p>
</div>
<div class="paragraph">
<p>For most uses, a <code>multi::array</code> should be preferred instead.</p>
</div>
<div class="paragraph">
<p>| Member types      | same as for <code>array_ref</code> |
|---                |---                        |</p>
</div>
<div class="paragraph">
<p>| Member fuctions   | same as for <code>array_ref</code> plus &#8230;&#8203; |
|---                |--- |
| (constructors)    | <code>static_array::static_array({e1, e2, &#8230;&#8203;}, T val = {}, Alloc = {})</code> constructs a D-dimensional array by allocating elements. <code>static_array::static_array(std::initializer_list&lt;&#8230;&#8203;&gt;</code> constructs the array with elements initialized from a nested list.
| (destructor)      | Destructor deallocates memory and destroy the elements |
| <code>operator=</code>       | assigns the elements from the source, sizes must match.</p>
</div>
<div class="paragraph">
<p>| Element access    | same as for <code>array_ref</code> |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Structure access  | same as for <code>array_ref</code> |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Iterators         | same as for <code>array_ref</code>   |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Capacity          | same as for <code>array_ref</code>   |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Creating views    | same as for <code>array_ref</code>  |
|---                |---  |</p>
</div>
<div class="paragraph">
<p>| Creating arrays   | same as for <code>array_ref</code>  |
|---                |---  |</p>
</div>
<div class="paragraph">
<p>| Relational fuctions   |  same as for <code>array_ref</code>  |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;class &lt;code&gt;multi::array&lt;T, D, Alloc = std::allocator&lt;T&gt; &gt;&lt;/code&gt;&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>An array of integer positive dimension D has value semantics if element type T has value semantics.
It supports stateful and polymorphic allocators, which is implied for the special type <code>multi::pmr::array&lt;T, D&gt;</code>.</p>
</div>
<div class="paragraph">
<p>| Member types      | same as for <code>static_array</code> (see above) |
|---                |---                         |</p>
</div>
<div class="paragraph">
<p>| Member fuctions   |    |
|---                |--- |
| (constructors)    | <code>array::array({e1, e2, &#8230;&#8203;}, T val = {}, Alloc = {})</code> constructs a D-dimensional array by allocating elements;`array::array(It first, It last)` and <code>array::array(Range const&amp; rng)</code>, same for a range of subarrays. <code>static_array::static_array(std::initializer_list&lt;&#8230;&#8203;&gt;, Alloc = {})</code> constructs the array with elements initialized from a nested list.
| (destructor)      | Destructor deallocates memory and destroy the elements |
| <code>operator=</code>       | assigns for a source <code>subarray</code>, or from another <code>array</code>. `array`s can be moved |</p>
</div>
<div class="paragraph">
<p>| Element access    | same as for <code>static_array</code> |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Structure access  | same as for <code>static_array</code> |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Iterators         | same as for <code>static_array</code>   |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Capacity          | same as for <code>static_array</code>  |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Creating views    | same as for <code>static_array</code>  |
|---                |---  |</p>
</div>
<div class="paragraph">
<p>| Creating arrays   | same as for <code>static_array</code>  |
|---                |---  |</p>
</div>
<div class="paragraph">
<p>| Relational fuctions   |  same as for <code>static_array</code>  |
|---                |--- |</p>
</div>
<div class="paragraph">
<p>| Manipulation      |     |
|---                |---  |
| <code>clear</code>           | Erases all elements from the container. The array is resized to zero size. |
| <code>reextent</code>        | Changes the size of the array to new extensions. <code>reextent({e1, e2, &#8230;&#8203;})</code> elements are preserved when possible. New elements are initialized with a default value <code>v</code> with a second argument <code>reextent({e1, e2, &#8230;&#8203;}, v)</code>. The first argument is of <code>extensions_type</code>, and the second is optional for element types with a default constructor. </p>
</div>
<div class="paragraph">
<p>&lt;/details&gt;</p>
</div>
<div class="paragraph">
<p>&lt;details&gt;&lt;summary&gt;class &lt;code&gt;multi::[sub]array&lt;T, D, P &gt;::(const_)iterator&lt;/code&gt;&lt;/summary&gt;</p>
</div>
<div class="paragraph">
<p>A random-access iterator to subarrays of dimension <code>D - 1</code>, that is generally used to interact with or implement algorithms.
They can be default constructed but do not expose other constructors since they are generally created from <code>begin</code> or <code>end</code>, manipulated arithmetically, <code>operator--</code>, <code>operator+` (pre and postfix), or random jumps `operator</code>/<code>operator-</code> and <code>operator+=</code>/<code>operator-=</code>.
They can be dereferenced by <code>operator*</code> and index access <code>operator[]</code>, returning objects of lower dimension <code>subarray&lt;T, D, &#8230;&#8203; &gt;::reference</code> (see above).
Note that this is the same type for all related arrays, for example, <code>multi::array&lt;T, D, P &gt;::(const_)iterator</code>.</p>
</div>
<div class="paragraph">
<p><code>iterator</code> can be invalidated when its original array is invalidated, destroyed or resized.
An <code>iterator</code> that stems from <code>static_array</code> becomes invalid only if the original array was destroyed or out-of-scope.
&lt;/details&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="interoperability"><a class="link" href="#interoperability">Interoperability</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="stl_standard_template_library"><a class="link" href="#stl_standard_template_library">STL (Standard Template Library)</a></h3>
<div class="paragraph">
<p>The fundamental goal of the library is that the arrays and iterators can be used with STL algorithms out-of-the-box with a reasonable efficiency.
The most dramatic example of this is that <code>std::sort</code> works with array as it is shown in a previous example.</p>
</div>
<div class="paragraph">
<p>Along with STL itself, the library tries to interact with other existing quality C++ libraries listed below.</p>
</div>
<div class="sect3">
<h4 id="ranges_c20"><a class="link" href="#ranges_c20">Ranges (C++20)</a></h4>
<div class="paragraph">
<p>[Standard ranges](<a href="https://en.cppreference.com/w/cpp/ranges" class="bare">https://en.cppreference.com/w/cpp/ranges</a>) extend standard algorithms, reducing the need for iterators, in favor of more composability and a less error-prone syntax.</p>
</div>
<div class="paragraph">
<p>In this example, we replace the values of the first row for which the sum of the elements is odd:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">accumulate</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_left</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">{});};</span>

	<span class="k">auto</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">{</span>
		<span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
		<span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>  <span class="c1">// this row adds to an odd number</span>
		<span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
	<span class="p">};</span>

	<span class="k">auto</span> <span class="k">const</span> <span class="n">row</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
	<span class="k">if</span><span class="p">(</span><span class="n">row</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>

	<span class="n">assert</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(live)](<a href="https://godbolt.org/z/cT9WGffM3" class="bare">https://godbolt.org/z/cT9WGffM3</a>)</p>
</div>
<div class="paragraph">
<p>Together with the array constructors, the ranges library enables a more functional programming style;
this allows us to work with immutable variables in many cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{{...}};</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">V</span> <span class="o">=</span> <span class="p">{...};</span>

	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">R</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">zip_transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">{},</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">V</span><span class="p">);</span>

	<span class="c1">// Alternative imperative mutating code:</span>
	<span class="c1">// multi::array&lt;double, 1&gt; R(V.size());  // R is created here...</span>
	<span class="c1">// for(auto i : R.extension()) {R[i] = A[0][i] + V[i];}  // ...and then mutated here</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(live)](<a href="https://godbolt.org/z/M84arKMnT" class="bare">https://godbolt.org/z/M84arKMnT</a>)</p>
</div>
<div class="paragraph">
<p>The "pipe" (<code>|</code>) notation of standard ranges allows one-line expressions.
In this example, the expression will yield the maximum value of the rows sums:
[<code>std::ranges::max(arr | std::views::transform(accumulate))</code>](<a href="https://godbolt.org/z/hvqnsf4xb" class="bare">https://godbolt.org/z/hvqnsf4xb</a>)</p>
</div>
<div class="paragraph">
<p>Like in classic STL, standard range algorithms acting on sequences operate in the first dimension by default,
for example, lexicographical sorting on rows can be performed with the <code>std::ranges::sort</code> algorithm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="k">auto</span> <span class="n">A</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">{</span>
		<span class="p">{</span><span class="sc">'S'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'n'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">},</span>
		<span class="p">{</span><span class="sc">'A'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">},</span>
		<span class="p">{</span><span class="sc">'B'</span><span class="p">,</span> <span class="sc">'j'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'r'</span><span class="p">,</span> <span class="sc">'n'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">},</span>
	<span class="p">};</span>
	<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>

	<span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>  <span class="c1">// will sort on rows</span>

	<span class="n">assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>

	<span class="n">assert</span><span class="p">(</span>
		<span class="n">A</span> <span class="o">==</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">{</span>
			<span class="p">{</span><span class="sc">'A'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">},</span>
			<span class="p">{</span><span class="sc">'B'</span><span class="p">,</span> <span class="sc">'j'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'r'</span><span class="p">,</span> <span class="sc">'n'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">},</span>
			<span class="p">{</span><span class="sc">'S'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'n'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">},</span>
		<span class="p">}</span>
	<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To operate on the second dimension (sort by columns), use <code>std::ranges::sort(~A)</code> (or <code>std::ranges::sort(A.transposed())</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="execution_policies_parallel_algorithms"><a class="link" href="#execution_policies_parallel_algorithms">Execution policies (parallel algorithms)</a></h4>
<div class="paragraph">
<p>Multi&#8217;s iterators can exploit parallel algorithms by specifying execution policies.
This code takes every row of a two-dimensional array and sums its elements, putting the results in a one-dimensional array of compatible size.
The execution policy (<code>par</code>) selected is passed as the first argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">A</span> <span class="o">=</span> <span class="p">...;</span>
    <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">row</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">row</span><span class="p">.</span><span class="n">end</span><span class="p">());}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(live)](<a href="https://godbolt.org/z/63jEdY7zP" class="bare">https://godbolt.org/z/63jEdY7zP</a>)</p>
</div>
<div class="paragraph">
<p>For an array of 10000x10000 elements, the execution time decreases to 0.0288 sec, compared to 0.0526 sec for the non-parallel version (i.e. without the <code>par</code> argument).</p>
</div>
<div class="paragraph">
<p>Note that parallelization is, in this context, inherently one-dimensional.
For example, parallelization happens for the transformation operation, but not to the summation.</p>
</div>
<div class="paragraph">
<p>The optimal way to parallelize specific operations strongly depends on the array&#8217;s size and shape.
Generally, straightforward parallelization without exploiting the n-dimensional structure of the data has a limited pay-off;
and nesting parallelization policies usually don&#8217;t help either.</p>
</div>
<div class="paragraph">
<p>Flattening the n-dimensional structure for certain algorithms might help, but such techniques are beyond the scope of this documentation.</p>
</div>
<div class="paragraph">
<p>Some member functions internally perform algorithms and that can benefit from execution policies;
in turn, some of these functions have the option to pass a policy.
For example, this copy construction can initialize elements in parallel from the source:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">A</span> <span class="o">=</span> <span class="p">...;</span>
    <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="k">const</span> <span class="nf">B</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>  <span class="c1">// copies A into B, in parallel, same effect as multi::array&lt;double, 1&gt; const B(A); or ... B = A;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Execution policies are not limited to STL;
Thrust and oneAPI also offer execution policies that can be used with the corresponding algorithms.</p>
</div>
<div class="paragraph">
<p>Execution policies and ranges can be mixed (<code>x</code> and <code>y</code> can be 1D dimensional arrays, of any arithmetic element type)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">X1D</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Y1D</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">dot_product</span><span class="p">(</span><span class="n">X1D</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Y1D</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
	<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ab</span><span class="p">)</span> <span class="p">{</span> <span class="k">auto</span> <span class="k">const</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">ab</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
		<span class="p">})</span>
	<span class="p">;</span>
	<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par_unseq</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">z</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(live)](<a href="https://godbolt.org/z/cMq87xPvb" class="bare">https://godbolt.org/z/cMq87xPvb</a>)</p>
</div>
</div>
<div class="sect3">
<h4 id="polymorphic_memory_resources"><a class="link" href="#polymorphic_memory_resources">Polymorphic Memory Resources</a></h4>
<div class="paragraph">
<p>In addition to supporting classic allocators (<code>std::allocator</code> by default), the library is compatible with C++17&#8217;s [polymorphic memory resources (PMR)](<a href="https://en.cppreference.com/w/cpp/header/memory_resource" class="bare">https://en.cppreference.com/w/cpp/header/memory_resource</a>), which allows using advanced allocation strategies, including preallocated buffers.
This example code uses a buffer as memory for two arrays; 
in it, a predefined buffer will contain the arrays' data (something like <code>"aaaabbbbbbXX"</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="c1">  // for polymorphic memory resource, monotonic buffer</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="s">"XXXXXXXXXXXX"</span><span class="p">;</span>  <span class="c1">// a small buffer on the stack</span>
	<span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">pool</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">data</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">buffer</span><span class="p">)};</span>

	<span class="n">multi</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="sc">'a'</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="sc">'b'</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="p">);</span>

	<span class="n">assert</span><span class="p">(</span> <span class="n">buffer</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">"XXXXXXXXXXXX"</span><span class="p">}</span> <span class="p">);</span>  <span class="c1">// overwritten w/elements, implementation-dependent (libstd consumes from left, and libc++, from the right)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>multi::pmr::array&lt;T, D&gt;</code> is a synonym for <code>multi::array&lt;T, D, std::pmr::polymorphic_allocator&lt;T&gt;&gt;</code>.
In this particular example, the technique can be used to avoid dynamic memory allocations of small local arrays. [(live)](<a href="https://godbolt.org/z/fP9P5Ksvb" class="bare">https://godbolt.org/z/fP9P5Ksvb</a>)</p>
</div>
<div class="paragraph">
<p>The library also supports memory resources from other libraries, including those returning special pointer types (see the [CUDA Thrust](#cuda-thrust) section and the Boost.Interprocess section).</p>
</div>
</div>
<div class="sect3">
<h4 id="substitutability_with_standard_vector_and_span"><a class="link" href="#substitutability_with_standard_vector_and_span">Substitutability with standard vector and span</a></h4>
<div class="paragraph">
<p>The one-dimensional case <code>multi::array&lt;T, 1&gt;</code> is special and overlaps functionality with other dynamic array implementations, such as <code>std::vector</code>.
Indeed, both types of containers are similar and usually substitutable, with no or minor modifications.
For example, both can be constructed from a list of elements (<code>C c = {x0, x2, &#8230;&#8203;};</code>) or from a size <code>C c(size);</code>, where <code>C</code> is either type.</p>
</div>
<div class="paragraph">
<p>Both values are assignable, have the same element access patterns and iterator interface, and implement all (lexical) comparisons.</p>
</div>
<div class="paragraph">
<p>They differ conceptually in their resizing operations: <code>multi::array&lt;T, 1&gt;</code> doesn&#8217;t insert or push elements and resizing works differently.
The difference is that the library doesn&#8217;t implement <strong>amortized</strong> allocations; therefore, these operations would be of a higher complexity cost than the <code>std::vector</code>.
For this reason, <code>resize(new_size)</code> is replaced with <code>reextent({new_size})</code> in <code>multi::array</code>, whose primary utility is for element preservation when necessary.</p>
</div>
<div class="paragraph">
<p>In a departure from standard containers, elements are left initialized if they have trivial constructor.
So, while <code>multi::array&lt;T, 1&gt; A({N}, T{})</code> is equivalent to <code>std::vector&lt;T&gt; V(N, T{})</code>, <code>multi::array&lt;T, 1&gt; A(N)</code> will leave elements <code>T</code> uninitialized if the type allows this (e.g. built-ins), unlike <code>std::vector&lt;T&gt; V(N)</code> which will initialize the values.
RAII types (e.g. <code>std::string</code>) do not have trivial default constructor, therefore they are not affected by this rule.</p>
</div>
<div class="paragraph">
<p>With the appropriate specification of the memory allocator, <code>multi::array&lt;T, 1, Alloc&gt;</code> can refer to special memory not supported by <code>std::vector</code>.</p>
</div>
<div class="paragraph">
<p>Finally, an array <code>A1D</code> can be copied by <code>std::vector&lt;T&gt; v(A1D.begin(), A1D.end());</code> or <code>v.assign(A1D.begin(), A1D.end());</code> or vice versa.
Without copying, a reference to the underlying memory can be created <code>auto&amp;&amp; R1D = multi::array_ref&lt;double, 1&gt;(v.data(), v.size());</code> or conversely <code>std::span&lt;T&gt;(A1D.data_elements(), A1D.num_elements());</code>. 
(See examples [here](<a href="https://godbolt.org/z/n4TY998o4" class="bare">https://godbolt.org/z/n4TY998o4</a>).)</p>
</div>
<div class="paragraph">
<p>The <code>std::span</code> (C++20) has not a well defined reference- or pointer-semantics; it doesn&#8217;t respect <code>const</code> correctness in generic code.
This behavior is contrary to the goals of this library;
and for this reason, there is no single substitute for <code>std::span</code> for all cases.
Depending on how it is used, either <code>multi::array_ref&lt;T, 1&gt; [const&amp; | &amp;&amp;]</code> or <code>multi::array_ptr&lt;T [const], 1&gt;</code> may replace the features of <code>std::span</code>.
The former typically works when using it as function argument.</p>
</div>
<div class="paragraph">
<p>Multi-dimensinal arrays can interoperate with C++23&#8217;s non-owning <code>mdspan</code>.
[Preliminarily](<a href="https://godbolt.org/z/aWW3vzfPj" class="bare">https://godbolt.org/z/aWW3vzfPj</a>), Multi&#8217;s subarrays (arrays) can be converted (viewed as) <code>mdspan</code>.</p>
</div>
<div class="paragraph">
<p>A detailed comparison with other array libraries (mspan, Boost.MultiArray, Eigen) is explained in an Appendix.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="serialization"><a class="link" href="#serialization">Serialization</a></h3>
<div class="paragraph">
<p>The ability to serialize arrays is essential for storing data in a persistent medium (files on disk) and communicating values via streams or networks (e.g., MPI).
Unfortunately, the C++ language does not provide facilities for serialization, and the standard library doesn&#8217;t either.</p>
</div>
<div class="paragraph">
<p>However, there are a few libraries that offer a certain common protocol for serialization,
such as [Boost.Serialization](<a href="https://www.boost.org/doc/libs/1_76_0/libs/serialization/doc/index.html" class="bare">https://www.boost.org/doc/libs/1_76_0/libs/serialization/doc/index.html</a>) and [Cereal](<a href="https://uscilab.github.io/cereal/" class="bare">https://uscilab.github.io/cereal/</a>).
The Multi library is compatible with both (and doesn&#8217;t depend on any of them).
The user can choose one or the other, or none, if serialization is not needed.
The generic protocol is such that variables are (de)serialized using the (<code>&gt;&gt;</code>)<code>&lt;&lt;</code> operator with the archive; operator <code>&amp;</code> can be used to have a single code for both.
Serialization can be binary (efficient) or text-based (human-readable).</p>
</div>
<div class="paragraph">
<p>Here, it is a small implementation of save and load functions for an array to JSON format with the Cereal library.
The example can be easily adapted to other formats or libraries.
(An alternative for XML with Boost.Serialization is commented on the right.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;multi/array.hpp&gt;</span><span class="c1">  // this library</span><span class="cp">
</span>
<span class="cp">#include</span><span class="cpf">&lt;cereal/archives/json.hpp&gt;</span><span class="c1">  // or #include&lt;cereal/archives/xml.hpp&gt;   // #include &lt;boost/archive/xml_iarchive.hpp&gt;</span><span class="cp">
</span>                                                                              <span class="c1">// #include &lt;boost/archive/xml_oarchive.hpp&gt;</span>
<span class="c1">// for serialization of array elements (in this case strings)</span>
<span class="cp">#include</span><span class="cpf">&lt;cereal/types/string.hpp&gt;</span><span class="c1">                                             // #include &lt;boost/serialization/string.hpp&gt;</span><span class="cp">
</span>
<span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="c1">  // saving to files in example</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">input_archive</span>  <span class="o">=</span> <span class="n">cereal</span><span class="o">::</span><span class="n">JSONInputArchive</span> <span class="p">;</span>  <span class="c1">// or ::XMLInputArchive ;  // or boost::archive::xml_iarchive;</span>
<span class="k">using</span> <span class="n">output_archive</span> <span class="o">=</span> <span class="n">cereal</span><span class="o">::</span><span class="n">JSONOutputArchive</span><span class="p">;</span>  <span class="c1">// or ::XMLOutputArchive;  // or boost::archive::xml_oarchive;</span>

<span class="k">using</span> <span class="n">cereal</span><span class="o">::</span><span class="n">make_nvp</span><span class="p">;</span>                                                       <span class="c1">// or boost::serialization::make_nvp;</span>

<span class="k">namespace</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">multi</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Element</span><span class="p">,</span> <span class="n">multi</span><span class="o">::</span><span class="n">dimensionality_type</span> <span class="n">D</span><span class="p">,</span> <span class="k">class</span> <span class="nc">IStream</span><span class="p">&gt;</span> 
<span class="k">auto</span> <span class="nf">array_load</span><span class="p">(</span><span class="n">IStream</span><span class="o">&amp;&amp;</span> <span class="n">is</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Element</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">input_archive</span><span class="p">{</span><span class="n">is</span><span class="p">}</span> <span class="o">&gt;&gt;</span> <span class="n">make_nvp</span><span class="p">(</span><span class="s">"value"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Element</span><span class="p">,</span> <span class="n">multi</span><span class="o">::</span><span class="n">dimensionality_type</span> <span class="n">D</span><span class="p">,</span> <span class="k">class</span> <span class="nc">OStream</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">array_save</span><span class="p">(</span><span class="n">OStream</span><span class="o">&amp;&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Element</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">output_archive</span><span class="p">{</span><span class="n">os</span><span class="p">}</span> <span class="o">&lt;&lt;</span> <span class="n">make_nvp</span><span class="p">(</span><span class="s">"value"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{{</span><span class="s">"w"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">},</span> <span class="p">{</span><span class="s">"y"</span><span class="p">,</span> <span class="s">"z"</span><span class="p">}};</span>
	<span class="n">array_save</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"file.string2D.json"</span><span class="p">),</span> <span class="n">A</span><span class="p">);</span>  <span class="c1">// use std::cout to print serialization to the screen</span>

	<span class="k">auto</span> <span class="k">const</span> <span class="n">B</span> <span class="o">=</span> <span class="n">array_load</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="p">(</span><span class="s">"file.string2D.json"</span><span class="p">));</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(online)](<a href="https://godbolt.org/z/Grr7Mqef5" class="bare">https://godbolt.org/z/Grr7Mqef5</a>)</p>
</div>
<div class="paragraph">
<p>These templated functions work for any dimension and element type (as long as the element type is serializable in itself; all basic types are serializable by default).
However, note that the user must ensure that data is serialized and deserialized into the same type;
the underlying serialization libraries only do minimal consistency checks for efficiency reasons and don&#8217;t try to second-guess file formats or contained types.
Serialization is a relatively low-level feature for which efficiency and economy of bytes are a priority.
Cryptic errors and crashes can occur if serialization libraries, file formats, or C++ types are mixed between writes and reads.
Some formats are human-readable but still not particularly pretty for showing as output (see the section on Formatting on how to print to the screen).</p>
</div>
<div class="paragraph">
<p>References to subarrays (views) can also be serialized; however, size information is not saved in such cases.
The reasoning is that references to subarrays cannot be resized in their number of elements if there is a size mismatch during deserialization.
Therefore, array views should be deserialized as other array views with matching sizes.</p>
</div>
<div class="paragraph">
<p>The output JSON file created by Cereal in the previous example looks like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nl">"value"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cereal_class_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
        </span><span class="nl">"extensions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"cereal_class_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
            </span><span class="nl">"extension"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"cereal_class_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="nl">"first"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="nl">"last"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"extension"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"first"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="nl">"last"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="nl">"elements"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"cereal_class_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
            </span><span class="nl">"item"</span><span class="p">:</span><span class="w"> </span><span class="s2">"w"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"item"</span><span class="p">:</span><span class="w"> </span><span class="s2">"x"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"item"</span><span class="p">:</span><span class="w"> </span><span class="s2">"y"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"item"</span><span class="p">:</span><span class="w"> </span><span class="s2">"z"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(The [Cereal XML](<a href="https://godbolt.org/z/de814Ycar" class="bare">https://godbolt.org/z/de814Ycar</a>) and Boost XML output would have a similar structure.)</p>
</div>
<div class="paragraph">
<p>Large datasets tend to be serialized slowly for archives with heavy formatting.
Here it is a comparison of speeds when (de)serializing a 134 MB 4-dimensional array of with random `double`s.</p>
</div>
<div class="paragraph">
<p>| Archive format (Library)     | file size     | speed (read - write)           | time (read - write)   |
| ---------------------------- | ------------- | ------------------------------ |-----------------------|
| JSON (Cereal)                | 684 MB        |    3.9 MB/sec  -   8.4 MB/sec  |  32.1 sec - 15.1  sec |
| XML (Cereal)                 | 612 MB        |    2.0  MB/sec -   4.0 MB/sec  |  56.0 sec - 28.0  sec |
| XML (Boost)                  | 662 MB        |   11.0  MB/sec -  13.0 MB/sec  |  11.0 sec -  9.0  sec |
| YAML ([custom archive)](<a href="https://gitlab.com/correaa/boost-archive-yml" class="bare">https://gitlab.com/correaa/boost-archive-yml</a>) | 702 MB        |   10.0  MB/sec -    4.4 MB/sec  |  12.0   sec  - 28.0   sec |
| Portable Binary (Cereal)     | 134 MB        |  130  MB/sec -  121  MB/sec  |  9.7  sec  - 10.6 sec |
| Text (Boost)                 | 411 MB        |   15.0  MB/sec -   16.0  MB/sec  |  8.2  sec  - 7.6  sec |
| Binary (Cereal)              | 134 MB        |  134.4 MB/sec -  126.  MB/sec  |  0.9  sec  -  0.9 sec |
| Binary (Boost)               | 134 MB        | 5200  MB/sec - 1600  MB/sec  |  0.02 sec -   0.1 sec |
| gzip-XML (Cereal)            | 191 MB        |    2.0  MB/sec -    4.0  MB/sec  | 61    sec  - 32   sec |
| gzip-XML (Boost)             | 207 MB        |    8.0  MB/sec -    8.0  MB/sec  | 16.1  sec  - 15.9 sec |</p>
</div>
</div>
<div class="sect2">
<h3 id="range_v3"><a class="link" href="#range_v3">Range-v3</a></h3>
<div class="paragraph">
<p>The library works out of the box with Eric Niebler&#8217;s Range-v3 library, a precursor to the standard Ranges library (see above).
The library helps removing explicit iterators (e.g. <code>begin</code>, <code>end</code>) from the code when possible.</p>
</div>
<div class="paragraph">
<p>Every Multi array object can be regarded as range.
Every subarray references (and array values) are interpreted as range views.</p>
</div>
<div class="paragraph">
<p>For example for a 2D array <code>d2D</code>, <code>d2D</code> itself is interpreted as a range of rows.
Each row, in turn, is interpreted as a range of elements.
In this way, <code>d2D.transposed()</code> is interpreted as a range of columns (of the original array), and each column a range of elements (arranged vertically in the original array).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;range/v3/all.hpp&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">d2D</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">},</span> 
		<span class="p">{</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">},</span> 
		<span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">},</span> 
		<span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">}</span>
	<span class="p">};</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">ranges</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="n">d2D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d2D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="mi">7</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span> <span class="p">);</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">ranges</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="n">d2D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotated</span><span class="p">(</span><span class="n">d2D</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">*</span><span class="mi">5</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="mi">15</span><span class="o">*</span><span class="mi">3</span> <span class="p">);</span>

	<span class="k">static_assert</span><span class="p">(</span><span class="n">ranges</span><span class="o">::</span><span class="n">RandomAccessIterator</span><span class="o">&lt;</span><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">{});</span>
	<span class="k">static_assert</span><span class="p">(</span><span class="n">ranges</span><span class="o">::</span><span class="n">RandomAccessIterator</span><span class="o">&lt;</span><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this other [example](<a href="https://godbolt.org/z/MTodPEnsr" class="bare">https://godbolt.org/z/MTodPEnsr</a>), a 2D Multi array (or subarray) is modified such that each element of a column is subtracted the mean value of such column.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;multi/array.hpp&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;range/v3/all.hpp&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">MultiArray2D</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">subtract_mean_columnwise</span><span class="p">(</span><span class="n">MultiArray2D</span><span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">tarr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">transposed</span><span class="p">();</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">column_mean</span> <span class="o">=</span> 
        <span class="n">tarr</span>
        <span class="o">|</span> <span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">ranges</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">/</span><span class="n">row</span><span class="p">.</span><span class="n">size</span><span class="p">();})</span>
        <span class="o">|</span> <span class="n">ranges</span><span class="o">::</span><span class="n">to</span><span class="o">&lt;</span><span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span>
    <span class="p">;</span>

    <span class="n">ranges</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">.</span><span class="n">elements</span><span class="p">(),</span>
        <span class="n">column_mean</span> <span class="o">|</span> <span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">cycle</span><span class="p">,</span>
        <span class="n">arr</span><span class="p">.</span><span class="n">elements</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span>
        <span class="p">[](</span><span class="k">auto</span> <span class="k">const</span> <span class="n">elem</span><span class="p">,</span> <span class="k">auto</span> <span class="k">const</span> <span class="n">mean</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">elem</span> <span class="o">-</span> <span class="n">mean</span><span class="p">;}</span>
    <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boost_interprocess"><a class="link" href="#boost_interprocess">Boost.Interprocess</a></h3>
<div class="paragraph">
<p>Using Interprocess allows for shared memory and for persistent mapped memory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;boost/interprocess/managed_mapped_file.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">"multi/array.hpp"</span><span class="cp">
#include</span><span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">bip</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="p">;</span>
<span class="k">using</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">bip</span><span class="o">::</span><span class="n">managed_mapped_file</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">mallocator</span> <span class="o">=</span> <span class="n">bip</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">manager</span><span class="o">::</span><span class="n">segment_manager</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">auto</span> <span class="nf">get_allocator</span><span class="p">(</span><span class="n">manager</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">){</span><span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">get_segment_manager</span><span class="p">();}</span>

<span class="k">namespace</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">multi</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">D</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">marray</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">mallocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
<span class="p">{</span>
	<span class="n">manager</span> <span class="n">m</span><span class="p">{</span><span class="n">bip</span><span class="o">::</span><span class="n">create_only</span><span class="p">,</span> <span class="s">"bip_mapped_file.bin"</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">};</span>
	<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">arr2d</span> <span class="o">=</span> <span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">construct</span><span class="o">&lt;</span><span class="n">marray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">"arr2d"</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="p">{</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">},</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">get_allocator</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
	<span class="n">arr2d</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">45.001</span><span class="p">;</span>
	<span class="n">m</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">{</span>
	<span class="n">manager</span> <span class="n">m</span><span class="p">{</span><span class="n">bip</span><span class="o">::</span><span class="n">open_only</span><span class="p">,</span> <span class="s">"bip_mapped_file.bin"</span><span class="p">};</span>
	<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">arr2d</span> <span class="o">=</span> <span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="o">&lt;</span><span class="n">marray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">"arr2d"</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">arr2d</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mf">45.001</span> <span class="p">);</span>
	<span class="n">m</span><span class="p">.</span><span class="n">destroy</span><span class="o">&lt;</span><span class="n">marray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">"arr2d"</span><span class="p">);</span><span class="c1">//    eliminate&lt;marray&lt;double, 2&gt;&gt;(m, "arr2d");}</span>
<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(Similarly works with [LLNL&#8217;s Meta Allocator](<a href="https://github.com/llnl/metall" class="bare">https://github.com/llnl/metall</a>))</p>
</div>
</div>
<div class="sect2">
<h3 id="cuda_and_hip_and_omp_and_tbb_via_thrust"><a class="link" href="#cuda_and_hip_and_omp_and_tbb_via_thrust">CUDA (and HIP, and OMP, and TBB) via Thrust</a></h3>
<div class="paragraph">
<p>The library works out-of-the-box in combination with the Thrust library.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;multi/array.hpp&gt;</span><span class="c1">  // this library</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;thrust/device_allocator.h&gt;</span><span class="c1">  // from CUDA or ROCm distributions</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">multi</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">device_allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">device_allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>
	<span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">;</span>

	<span class="n">thrust</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">rotated</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">rotated</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">rotated</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">begin</span><span class="p">());</span>  <span class="c1">// copy row 0</span>
	<span class="n">assert</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">50.0</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(live)](<a href="https://godbolt.org/z/e7bjKqh69" class="bare">https://godbolt.org/z/e7bjKqh69</a>)</p>
</div>
<div class="paragraph">
<p>which uses the default Thrust device backend (i.e. CUDA when compiling with <code>nvcc</code>, HIP/ROCm when compiling with a HIP/ROCm compiler, or OpenMP or TBB in other cases).
Universal memory (accessible from normal CPU code) can be used with <code>thrust::universal_allocator</code> (from <code>&lt;thrust/universal_allocator.h&gt;</code>) instead.</p>
</div>
<div class="paragraph">
<p>More specific allocators can be used ensure CUDA backends, for example CUDA managed memory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;thrust/system/cuda/memory.h&gt;</span><span class="cp">
</span><span class="p">...</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">universal_allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the same way, to <strong>ensure</strong> HIP backends please replace the <code>cuda</code> namespace by the <code>hip</code> namespace, and in the directory name <code>&lt;thrust/system/hip/memory.h&gt;</code>.
<code>&lt;thrust/system/hip/memory.h&gt;</code> is provided by rocThrust in the ROCm distribution (in <code>/opt/rocm/include/thrust/system/hip/</code>, and not by the NVIDIA distribution.)</p>
</div>
<div class="paragraph">
<p>Multi doesn&#8217;t have a dependency on Thrust (or vice versa);
they just work well together, both in terms of semantics and efficiency.
Certain "patches" (to improve Thrust behavior) can be applied to Thrust to gain extra efficiency and achieve near native speed by adding the <code>#include&lt;multi/adaptors/thrust.hpp&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Multi can be used on existing memory in a non-invasive way via (non-owning) reference arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="c1">// assumes raw_pointer was allocated with cudaMalloc or hipMalloc</span>
	<span class="k">using</span> <span class="n">gpu_ptr</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">pointer</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// or thrust::hip::pointer&lt;double&gt; </span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array_ref</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">gpu_ptr</span><span class="o">&gt;</span> <span class="n">Aref</span><span class="p">({</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">},</span> <span class="n">gpu_ptr</span><span class="p">{</span><span class="n">raw_pointer</span><span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the element type of the device array has to be device-friendly to work correctly; 
this includes all build in types, and classes with basic device operations, such as construction, destruction, and assigment.
They notably do not include <code>std::complex&lt;T&gt;</code>, in which can be replaced by the device-friendly <code>thrust::complex&lt;T&gt;</code> can be used as replacement.</p>
</div>
<div class="sect3">
<h4 id="openmp_via_thrust"><a class="link" href="#openmp_via_thrust">OpenMP via Thrust</a></h4>
<div class="paragraph">
<p>In an analogous way, Thrust can also handle OpenMP (omp) allocations and multi-threaded algorithms of arrays.
The OMP backend can be enabled by the compiler flags <code>-DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_BACKEND_OMP</code> or by using the explicit <code>omp</code> system types: </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;multi/array.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thrust/system/omp/memory.h&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">multi</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">omp</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">omp</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>

	<span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">;</span>

    <span class="c1">// copy row 0</span>
	<span class="n">thrust</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">rotated</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">rotated</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">rotated</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">begin</span><span class="p">());</span>

	<span class="n">assert</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">50.0</span> <span class="p">);</span>

	<span class="k">auto</span> <span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>  <span class="c1">// uses omp automatically for copying behind the scenes</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://godbolt.org/z/e3cGbY87r" class="bare">https://godbolt.org/z/e3cGbY87r</a></p>
</div>
<div class="paragraph">
<p>Compilation might need to link to an omp library, <code>-fopenmp -lgomp</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="thrust_memory_resources"><a class="link" href="#thrust_memory_resources">Thrust memory resources</a></h4>
<div class="paragraph">
<p>GPU memory is relative expensive to allocate, therefore any application that allocates and deallocates arrays often will suffer performance issues.
This is where special memory management is important, for example for avoiding real allocations when possible by caching and reusing memory blocks.</p>
</div>
<div class="paragraph">
<p>Thrust implements both polymorphic and non-polymorphic memory resources via <code>thrust::mr::allocator&lt;T, MemoryResource&gt;</code>;
Multi supports both.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">disjoint_unsynchronized_pool_resource</span><span class="p">(</span>
	<span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">get_global_resource</span><span class="o">&lt;</span><span class="n">thrust</span><span class="o">::</span><span class="n">universal_memory_resource</span><span class="o">&gt;</span><span class="p">(),</span>
	<span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">get_global_resource</span><span class="o">&lt;</span><span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">new_delete_resource</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">);</span>

<span class="c1">// memory is handled by pool, not by the system allocator</span>
<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">arr</span><span class="p">({</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">},</span> <span class="o">&amp;</span><span class="n">pool</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The associated pointer type for the array data is deduced from the <em>upstream</em> resource; in this case, <code>thrust::universal_ptr&lt;int&gt;</code>.</p>
</div>
<div class="paragraph">
<p>As as quick way to improve performance in many cases, here it is a recipe for a <code>caching_allocator</code> which uses a global (one per thread) memory pool that can replace the default Thrust allocator.
The requested memory resides in GPU (managed) memory (<code>thrust::cuda::universal_memory_resource</code>) while the cache <em>bookkeeping</em> is held in CPU memory (<code>new_delete_resource</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Base_</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">&lt;</span><span class="n">thrust</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">universal_pointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">&gt;</span><span class="o">&gt;&gt;&gt;</span>
<span class="k">struct</span> <span class="nc">caching_allocator</span> <span class="o">:</span> <span class="n">Base_</span> <span class="p">{</span>
	<span class="n">caching_allocator</span><span class="p">()</span> <span class="o">:</span> 
		<span class="n">Base_</span><span class="p">{</span><span class="o">&amp;</span><span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">tls_disjoint_pool</span><span class="p">(</span>
			<span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">get_global_resource</span><span class="o">&lt;</span><span class="n">thrust</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">universal_memory_resource</span><span class="o">&gt;</span><span class="p">(),</span>
			<span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">get_global_resource</span><span class="o">&lt;</span><span class="n">thrust</span><span class="o">::</span><span class="n">mr</span><span class="o">::</span><span class="n">new_delete_resource</span><span class="o">&gt;</span><span class="p">()</span>
		<span class="p">)}</span> <span class="p">{}</span>
	<span class="n">caching_allocator</span><span class="p">(</span><span class="n">caching_allocator</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">:</span> <span class="n">caching_allocator</span><span class="p">{}</span> <span class="p">{}</span>  <span class="c1">// all caching allocators are equal</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">rebind</span> <span class="p">{</span> <span class="k">using</span> <span class="n">other</span> <span class="o">=</span> <span class="n">caching_allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">;</span> <span class="p">};</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="k">using</span> <span class="n">array2D</span> <span class="o">=</span> <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">caching_allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">array2D</span> <span class="n">A</span><span class="p">({</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">});</span> <span class="cm">/*... use A ...*/</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://godbolt.org/z/rKG8PhsEh" class="bare">https://godbolt.org/z/rKG8PhsEh</a></p>
</div>
<div class="paragraph">
<p>In the example, most of the frequent memory requests are handled by reutilizing the memory pool avoiding expensive system allocations.
More targeted usage patterns may require locally (non-globally) defined memory resources.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cuda_c"><a class="link" href="#cuda_c">CUDA C++</a></h3>
<div class="paragraph">
<p>CUDA is a dialect of C++ that allows writing pieces of code for GPU execution, known as "CUDA kernels".
CUDA code is generally "low level" (less abstracted) but it can be used in combination with CUDA Thrust or the CUDA runtime library, specially to implement custom algorithms.
Although code inside kernels has certain restrictions, most Multi features can be used. 
(Most functions in Multi, except those involving memory allocations, are marked <code><em>device</em></code> to allow this.)</p>
</div>
<div class="paragraph">
<p>Calling kernels involves a special syntax (<code>&lt;&lt;&lt; &#8230;&#8203; &gt;&gt;&gt;</code>), and they cannot take arguments by reference (or by values that are not trivial).
Since arrays are usually passed by reference (e.g. <code>multi::array&lt;double, 2&gt;&amp;</code> or <code>Array&amp;&amp;</code>), a different idiom needs to be used.
(Large arrays are not passed by value to avoid copies, but even if a copy would be fine, kernel arguments cannot allocate memory themselves.)
Iterators (e.g. <code>.begin()/.end()</code>) and "cursors" (e.g. <code>.home()</code>) are "trivial to copy" and can be passed by value and represent a "proxy" to an array, including allowing the normal index syntax and other transformations.</p>
</div>
<div class="paragraph">
<p>Cursors are a generalization of iterators for multiple dimensions.
They are cheaply copied (like iterators) and they allow indexing.
Also, they have no associated <code>.size()</code> or <code>.extensions()</code>, but this is generally fine for kernels.
(Since <code>cursors</code> have minimal information for indexing, they can save stack/register space in individual kernels.)</p>
</div>
<div class="paragraph">
<p>Here it is an example implementation for matrix multiplication, in combination with Thrust and Multi,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;multi/array.hpp&gt;</span><span class="c1">  // from https://gitlab.com/correaa/boost-multi</span><span class="cp">
#include</span> <span class="cpf">&lt;thrust/system/cuda/memory.h&gt;</span><span class="c1">  // for thrust::cuda::allocator</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ACursor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BCursor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">CCursor</span><span class="p">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">Kernel</span><span class="p">(</span><span class="n">ACursor</span> <span class="n">A</span><span class="p">,</span> <span class="n">BCursor</span> <span class="n">B</span><span class="p">,</span> <span class="n">CCursor</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

	<span class="k">typename</span> <span class="n">CCursor</span><span class="o">::</span><span class="n">element_type</span> <span class="n">value</span><span class="p">{</span><span class="mf">0.0</span><span class="p">};</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">x</span><span class="p">];</span> <span class="p">}</span>
	<span class="n">C</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">multi</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="c1">// declare 3 square arrays</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">({</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">});</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">...;</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">({</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">});</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">...;</span>
	<span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">C</span><span class="p">({</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">});</span>

	<span class="c1">// kernel invocation code</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="mi">32</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dim3</span> <span class="nf">dimBlock</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">dim3</span> <span class="nf">dimGrid</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">32</span><span class="p">,</span> <span class="n">N</span><span class="o">/</span><span class="mi">32</span><span class="p">);</span>
	<span class="n">Kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span> <span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">home</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">home</span><span class="p">(),</span> <span class="n">C</span><span class="p">.</span><span class="n">home</span><span class="p">(),</span> <span class="n">N</span><span class="p">);</span>
	<span class="n">cudaDeviceSynchronize</span><span class="p">();</span>

    <span class="c1">// now C = A x B</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(live)](<a href="https://godbolt.org/z/eKbeosrWa" class="bare">https://godbolt.org/z/eKbeosrWa</a>)</p>
</div>
<div class="paragraph">
<p>Expressions such as <code>A.begin()</code> (iterators) can also be passed to kernels, but they could unnecessarely occupy more kernel "stack space" when size information is not needed (e.g. <code>A.begin()&#8594;size()</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="sycl"><a class="link" href="#sycl">SYCL</a></h3>
<div class="paragraph">
<p>The SYCL library promises the unify CPU, GPU and FPGA code.
At the moment, the array containers can use the Unified Shared Memory (USM) allocator, but no other tests have been investigated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">sycl</span><span class="o">::</span><span class="n">queue</span> <span class="n">q</span><span class="p">;</span>

    <span class="n">sycl</span><span class="o">::</span><span class="n">usm_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">sycl</span><span class="o">::</span><span class="n">usm</span><span class="o">::</span><span class="n">alloc</span><span class="o">::</span><span class="n">shared</span><span class="o">&gt;</span> <span class="n">q_alloc</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">q_alloc</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">q_alloc</span><span class="p">);</span>

    <span class="c1">//# Offload parallel computation to device</span>
    <span class="n">q</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">base</span><span class="p">()]</span> <span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}).</span><span class="n">wait</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://godbolt.org/z/8WG8qaf4s" class="bare">https://godbolt.org/z/8WG8qaf4s</a></p>
</div>
<div class="paragraph">
<p>Algorithms are expected to work with oneAPI execution policies as well (not tested)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="k">auto</span> <span class="n">policy</span> <span class="o">=</span> <span class="n">oneapi</span><span class="o">::</span><span class="n">dpl</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">dpcpp_default</span><span class="p">;</span>
    <span class="n">sycl</span><span class="o">::</span><span class="n">usm_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">sycl</span><span class="o">::</span><span class="n">usm</span><span class="o">::</span><span class="n">alloc</span><span class="o">::</span><span class="n">shared</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">(</span><span class="n">policy</span><span class="p">.</span><span class="n">queue</span><span class="p">());</span>
    <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alloc</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">42</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="formatting_fmt_pretty_printing"><a class="link" href="#formatting_fmt_pretty_printing">Formatting ({fmt} pretty printing)</a></h3>
<div class="paragraph">
<p>The library doesn&#8217;t have a "pretty" printing facility to display arrays.
Although it is not ideal, arrays can be printed and formated by looping over elements and dimension, as shown in other examples (using standard streams).</p>
</div>
<div class="paragraph">
<p>Fortunatelly, the library automatically works with the external library [{fmt}](<a href="https://fmt.dev/latest/index.html" class="bare">https://fmt.dev/latest/index.html</a>), both for arrays and subarrays.
The fmt library is not a dependency of the Multi library; they simply work well together using the "ranges" part of the formatting library.
fmt allows a high degree of confurability.</p>
</div>
<div class="paragraph">
<p>This example prints a 2-dimensional subblock of a larger array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">"fmt/ranges.h"</span><span class="cp">
</span><span class="p">...</span>
    <span class="n">multi</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>      <span class="mf">3.0</span><span class="p">},</span> 
        <span class="cm">/*-subblock-**/</span>
        <span class="p">{</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="cm">/**/</span> <span class="mf">5.0</span><span class="p">},</span>
        <span class="p">{</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="cm">/**/</span> <span class="mf">8.0</span><span class="p">},</span>
    <span class="p">};</span>

    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"A2 subblock = {}"</span><span class="p">,</span> <span class="n">A2</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}));</span>  <span class="c1">// second and third row, first and second column</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>obtaining the "flat" output <code>A2 subblock = [[3, 4], [6, 7]]</code>.
(A similar effect can be achieved with [experimental C23 `std::print` in libc]( <a href="https://godbolt.org/z/4ehd4s5vf" class="bare">https://godbolt.org/z/4ehd4s5vf</a>).)</p>
</div>
<div class="paragraph">
<p>For 2 or more dimensions the output can be conveniently structured in different lines using the <code>fmt::join</code> facility:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fmt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">A2</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}),</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>  <span class="c1">// first dimension rows are printer are in different lines</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with the output:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span></code></pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In same way, the size of the array can be printed simply by passing the sizes output; <code>fmt::print("{}", A2(&#8230;&#8203;).sizes() )</code>, which print <code>(2, 2)</code>.</p>
</div>
<div class="paragraph">
<p><a href="https://godbolt.org/z/WTEfnMG7n" class="bare">https://godbolt.org/z/WTEfnMG7n</a></p>
</div>
<div class="paragraph">
<p>When saving arrays to files, consider using serialization (see section) instead of formatting facilities.</p>
</div>
</div>
<div class="sect2">
<h3 id="legacy_libraries_c_apis"><a class="link" href="#legacy_libraries_c_apis">Legacy libraries (C-APIs)</a></h3>
<div class="paragraph">
<p>Multi-dimensional array data structures exist in all languages, whether implicitly defined by its strides structure or explicitly at the language level.
Functions written in C tend to receive arrays by pointer arguments (e.g., to the "first" element) and memory layout (sizes and strides).</p>
</div>
<div class="paragraph">
<p>A C-function taking a 2D array with a concrete type might look like this in the general case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stride1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stride2</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>such a function can be called from C++ on Multi array (<code>arr</code>), by extracting the size and layout information,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">fun</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">base</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">sizes</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">sizes</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">strides</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">strides</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="k">const</span> <span class="p">[</span><span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">sizes</span><span class="p">();</span>
<span class="k">auto</span> <span class="k">const</span> <span class="p">[</span><span class="n">stride1</span><span class="p">,</span> <span class="n">stride2</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">strides</span><span class="p">();</span>

<span class="n">fun</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">base</span><span class="p">(),</span> <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">,</span> <span class="n">stride1</span><span class="p">,</span> <span class="n">stride2</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Although the recipe can be applied straightforwardly, different libraries make various assumptions about memory layouts (e.g.,  2D arrays assume that the second stride is 1), and some might take stride information in a different way (e.g., FFTW doesn&#8217;t use strides but stride products).
Furthermore, some arguments may need to be permuted if the function expects arrays in column-major (Fortran) ordering.</p>
</div>
<div class="paragraph">
<p>For these reasons, the library is accompanied by a series of adaptor libraries to popular C-based libraries, which can be found in the <code>include/multi/adaptors/</code> subdirectory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><mark>#</mark> [BLAS/cuBLAS Adator ð](include/boost/multi/adaptors/blas/README.md)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interface for BLAS-like linear algebra libraries, such as openblas, Apple&#8217;s Accelerate, MKL and hipBLAS/cuBLAS (GPUs).
Simply <code>#include "multi/adaptors/blas.hpp"</code> (and link your program with <code>-lblas</code> for example).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><mark>#</mark> Lapack</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interface for Lapack linear solver libraries.
Simply <code>#include "multi/adaptors/lapack.hpp"</code> (and link your program with <code>-llapack</code> for example).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><mark>#</mark> FFTW/cuFFT</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interface for FFTW libraries, including FFTW 3, MKL, cuFFT/hipFFT (for GPU).
Simply <code>#include "multi/adaptors/fftw.hpp"</code> (and link your program with <code>-lfftw3</code> for example).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><mark>#</mark> [MPI Adaptor ð](include/boost/multi/adaptors/mpi/README.md)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use arrays (and subarrays) as messages for distributed interprocess communication (GPU and CPU) that can be passed to MPI functions through datatypes.
Simply <code>#include "multi/adaptors/mpi.hpp"</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><mark>#</mark> TotalView: visual debugger (commercial)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Popular in HPC environments, can display arrays in human-readable form (for simple types, like <code>double</code> or <code>std::complex</code>).
Simply <code>#include "multi/adaptors/totalview.hpp"</code> and link to the TotalView libraries, compile and run the code with the TotalView debugger.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="technical_points"><a class="link" href="#technical_points">Technical points</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="indexing_square_brackets_vs_parenthesis"><a class="link" href="#indexing_square_brackets_vs_parenthesis">Indexing (square brackets vs. parenthesis?)</a></h3>
<div class="paragraph">
<p>The chained bracket notation (<code>A[i][j][k]</code>) allows you to refer to elements and lower-dimensional subarrays consistently and generically, and it is the recommended way to access array objects.
It is a frequently raised question whether the chained bracket notation is beneficial for performance, as each use of the bracket leads to the creation of temporary objects, which in turn generates a partial copy of the layout.
Moreover, this goes against [historical recommendations](<a href="https://isocpp.org/wiki/faq/operator-overloading#matrix-subscript-op" class="bare">https://isocpp.org/wiki/faq/operator-overloading#matrix-subscript-op</a>).</p>
</div>
<div class="paragraph">
<p>It turns out that modern compilers with a fair level of optimization (<code>-O2</code>) can elide these temporary objects so that <code>A[i][j][k]</code> generates identical machine code as <code>A.base() + i*stride1 + j*stride2 + k*stride3</code> (+offsets not shown).
In a subsequent optimization, constant indices can have their "partial stride" computation removed from loops. 
As a result, these two loops lead to the [same machine code](<a href="https://godbolt.org/z/ncqrjnMvo" class="bare">https://godbolt.org/z/ncqrjnMvo</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">	<span class="c1">// given the values of i and k and accumulating variable acc ...</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="n">acc</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="k">auto</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">base</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">strides</span><span class="p">())</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">strides</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="n">acc</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">strides</span><span class="p">()));}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Incidentally, the library also supports parenthesis notation with multiple indices <code>A(i, j, k)</code> for element or partial access;
it does so as part of a more general syntax to generate sub-blocks.
In any case, <code>A(i, j, k)</code> is expanded to <code>A[i][j][k]</code> internally in the library when <code>i</code>, <code>j</code>, and <code>k</code> are normal integer indices.
For this reason, <code>A(i, j, k)</code>, <code>A(i, j)(k)</code>, <code>A(i)(j)(k)</code>, <code>A[i](j)[k]</code> are examples of equivalent expressions.</p>
</div>
<div class="paragraph">
<p>Sub-block notation, when at least one argument is an index range, e.g., <code>A({i0, i1}, j, k)</code> has no equivalent square-bracket notation.
Note also that <code>A({i0, i1}, j, k)</code> is not equivalent to <code>A({i0, i1})(j, k)</code>; their resulting sublocks have different dimensionality.</p>
</div>
<div class="paragraph">
<p>Additionally, array coordinates can be directly stored in tuple-like data structures, allowing this functional syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">234</span><span class="p">;</span>  <span class="c1">// same as assignment A(2, 3, 4) = 234; and same as A[2][3][4] = 234;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="iteration_past_end_in_the_abstract_machine"><a class="link" href="#iteration_past_end_in_the_abstract_machine">Iteration past-end in the abstract machine</a></h3>
<div class="paragraph">
<p>It&#8217;s crucial to grasp that pointers are limited to referencing valid memory in the strict C abstract machine, such as allocated memory.
This understanding is key to avoiding undefined behavior in your code.
Since the library iteration is pointer-based, the iterators replicate these restrictions.</p>
</div>
<div class="paragraph">
<p>There are three cases to consider; the first two can be illustrated with one-dimensional arrays, and one is intrinsic to multiple dimensions.</p>
</div>
<div class="paragraph">
<p>The first case is that of strided views (e.g. <code>A.strided(n)</code>) whose stride value are not divisors of original array size.
The second case is that or negative strides in general.
The third case is that of iterators of transposed array.</p>
</div>
<div class="paragraph">
<p>In all these cases, the <code>.end()</code> iterator may point to invalid memory. 
It&#8217;s important to note that the act of constructing certain iterators, even if the elementÂ is never dereferenced, is undefined in the abstract machine.
This underscores the need for caution when using such operations in your code.</p>
</div>
<div class="paragraph">
<p>A thorough description of the cases and workaround is beyond the scope of this section.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_comparison_to_other_array_libraries_mdspan_boost_multiarray_etc"><a class="link" href="#appendix_comparison_to_other_array_libraries_mdspan_boost_multiarray_etc">Appendix: Comparison to other array libraries (mdspan, Boost.MultiArray, etc)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The C++23 standard provides <code>std::mdspan</code>, a non-owning <em>multidimensional</em> array.
So here is an appropriate point to compare the two libraries.
Although the goals are similar, the two libraries differ in their generality and approach.</p>
</div>
<div class="paragraph">
<p>The Multi library concentrates on <em>well-defined value- and reference-semantics of arbitrary memory types with regularly arranged elements</em> (distributions described by strides and offsets) and <em>extreme compatibility with STL algorithms</em> (via iterators) and other fundamental libraries.
While <code>mdspan</code> concentrates on <em>arbitrary layouts</em> for non-owning memory of a single type (CPU raw pointers).
Due to the priority of arbitrary layouts, the <code>mdspan</code> research team didn&#8217;t find efficient ways to introduce iterators into the library. 
Therefore, its compatibility with the rest of the STL is lacking.
[Preliminarily](<a href="https://godbolt.org/z/aWW3vzfPj" class="bare">https://godbolt.org/z/aWW3vzfPj</a>), Multi array can be converted (viewed as) <code>mdspan</code>.</p>
</div>
<div class="paragraph">
<p>[Boost.MultiArray](<a href="https://www.boost.org/doc/libs/1_82_0/libs/multi_array/doc/user.html" class="bare">https://www.boost.org/doc/libs/1_82_0/libs/multi_array/doc/user.html</a>) is the original multidimensional array library shipped with Boost.
This library can replace Boost.MultiArray in most contexts, it even fulfillis the concepts of <code>boost::multi_array_concepts::ConstMultiArrayConcept</code> and <code>&#8230;&#8203;::MutableMultiArrayConcept</code>.
Boost.MultiArray has technical and semantic limitations that are overcome in this library, regarding layouts and references;
it doesn&#8217;t support value-semantics, iterator support is limited and it has other technical problems.</p>
</div>
<div class="paragraph">
<p>[Eigen](<a href="https://eigen.tuxfamily.org/index.php?title=Main_Page" class="bare">https://eigen.tuxfamily.org/index.php?title=Main_Page</a>) is a very popular matrix linear algebra framework library, and as such, it only handles the special 2D (and 1D) array case.
Instead, the Multi library is dimension-generic and doesn&#8217;t make any algebraic assumptions for arrays or contained elements (but still can be used to <em>implement</em>, or in combination, with dense linear algebra algorithms.)</p>
</div>
<div class="paragraph">
<p>Other frameworks includes the OpenCV (Open Computing Vision) framework, which is too specialized to make a comparison here.</p>
</div>
<div class="paragraph">
<p>Here is a table comparing with <code>mdspan</code>, R. Garcia&#8217;s [Boost.MultiArray](<a href="https://www.boost.org/doc/libs/1_82_0/libs/multi_array/doc/user.html" class="bare">https://www.boost.org/doc/libs/1_82_0/libs/multi_array/doc/user.html</a>) and Eigen. 
[(online)](<a href="https://godbolt.org/z/555893MqW" class="bare">https://godbolt.org/z/555893MqW</a>).</p>
</div>
<div class="paragraph">
<p>|                             | Multi                                                           | mdspan/mdarray                                                                          | Boost.MultiArray (R. Garcia)                                                                         | Inria&#8217;s Eigen                                                                           |
|---                          | ---                                                             | ---                                                                             | ---                                                                                                  | ---                                                                                     |
| No external Deps            | <strong>yes</strong> (only Standard Library C17)                           | **yes** (only Standard Library C17/C26)                                                 | **yes** (only Boost)                                                                                 | **yes**                                                                                 |
| Arbritary number of dims    | **yes**, via positive dimension (compile-time) parameter `D`    | **yes**                                                                         | **yes**                                                                                              | no  (only 1D and 2D)                                                                    |
| Non-owning view of data     | **yes**, via `multi::array_ref&lt;T, D&gt;(ptr, {n1, n2, ..., nD})`   | **yes**, via `mdspan m{T*, extents{n1, n2, ..., nD}};`                          | **yes**, via `boost::multi_array_ref&lt;T, D&gt;(T*, boost::extents[n1][n2]...[nD])` | **yes**, via `Eigen::Map&lt;Eigen::Array&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;&gt;(ptr, n1, n2)` |
| Compile-time dim size       | no                                                              | **yes**, via template paramaters `mdspan{T*, extent&lt;16, dynamic_extents&gt;{32} }` | no                                                                             | **yes**, via `Eigen::Array&lt;T, N1, N2&gt;` |
| Array values (owning data)  | **yes**, via `multi::array&lt;T, D&gt;({n1, n2, ..., nD})`            | yes for `mdarray`                                               | **yes**, via `boost::multi_array&lt;T, D&gt;(boost::extents[n1][n2]...[nD])` | **yes**, via `Eigen::Array&lt;T&gt;(n1, n2)` |
| Value semantic (Regular)    | **yes**, via cctor, mctor, assign, massign, auto decay of views | yes (?) for `mdarray` planned                                   | partial, assigment on equal extensions  | **yes** (?) |
| Move semantic               | **yes**, via mctor and massign                                  | yes (?) for `mdarray` (depends on adapted container)            | no (C98 library)                      | <strong>yes</strong> (?) |
| const-propagation semantics | <strong>yes</strong>, via <code>const</code> or <code>const&amp;</code>                                | no, const mdspan elements are assignable!                       | no, inconsistent                        | (?) |
| Element initialization      | <strong>yes</strong>, via nested init-list                                   | no (?)                                                          | no                                      | no, only delayed init via <code>A &lt;&lt; v1, v2, &#8230;&#8203;;</code> |
| References w/no-rebinding   | <strong>yes</strong>, assignment is deep                                     | no, assignment of mdspan rebinds!                               | <strong>yes</strong>                                 | <strong>yes</strong> (?) |
| Element access              | <strong>yes</strong>, via <code>A(i, j, &#8230;&#8203;)</code> or <code>A[i][j]&#8230;&#8203;</code>                     | <strong>yes</strong>, via <code>A[i, j, &#8230;&#8203;]</code>                                     | <strong>yes</strong>, via <code>A[i][j]&#8230;&#8203;</code>               | <strong>yes</strong>, via <code>A(i, j)</code> (2D only) |
| Partial element access      | <strong>yes</strong>, via <code>A[i]</code> or <code>A(i, multi::all)</code>                       | no, only via <code>submdspan(A, i, full_extent)</code>                     | <strong>yes</strong>, via <code>A[i]</code>                     | <strong>yes</strong>, via <code>A.row(i)</code> |
| Subarray views              | <strong>yes</strong>, via <code>A({0, 2}, {1, 3})</code> or <code>A(1, {1, 3})</code>              | <strong>yes</strong>, via <code>submdspan(A, std::tuple{0, 2}, std::tuple{1, 3})</code> | <strong>yes</strong>, via <code>A[indices[range(0, 2)][range(1, 3)]]</code> | <strong>yes</strong>, via <code>A.block(i, j, di, dj)</code> |
| Subarray with lower dim     | <strong>yes</strong>, via <code>A(1, {1, 3})</code>                                     | <strong>yes</strong>, via <code>submdspan(A, 1, std::tuple{1, 3})</code>                | <strong>yes</strong>, via <code>A[1][indices[range(1, 3)]]</code>                    | <strong>yes</strong>, via <code>A(1, Eigen::placeholders::all)</code> |
| Subarray w/well def layout  | <strong>yes</strong> (strided layout)                                        | no                                                              | <strong>yes</strong> (strided layout)                      | <strong>yes</strong> (strided) |
| Recursive subarray          | <strong>yes</strong> (layout is stack-based and owned by the view)           | <strong>yes</strong> (?)                                                     | no (subarray may dangle layout, design bug?)  | <strong>yes</strong> (?) (1D only) |
| Custom Alloctors            | <strong>yes</strong>, via <code>multi::array&lt;T, D, Alloc&gt;</code>                        | yes(?) through <code>mdarray&#8217;s adapted container                    | <strong>yes</strong> (stateless?)                          | no | 
| PMR Alloctors               | <strong>yes</strong>, via `multi::pmr::array&lt;T, D&gt;</code>                          | yes(?) through <code>mdarray&#8217;s adapted container                    |   no                          | no |
| Fancy pointers / references | <strong>yes</strong>, via `multi::array&lt;T, D, FancyAlloc&gt;</code> or views          | no                                                              |   no                          | no |
| Stride-based Layout         | <strong>yes</strong>                                                         | <strong>yes</strong>                                                   |  <strong>yes</strong>                      | <strong>yes</strong> |
| Fortran-ordering            | <strong>yes</strong>, only for views, e.g. resulted from transposed views    | <strong>yes</strong>                                                   |  <strong>yes</strong>.                     | <strong>yes</strong> |
| Zig-zag / Hilbert ordering  | no                                                              | <strong>yes</strong>, via arbitrary layouts (no inverse or flattening) | no                            | no |
| Arbitrary layout            | no                                                              | <strong>yes</strong>, possibly inneficient, no efficient slicing       | no                            | no |
| Flattening of elements      | <strong>yes</strong>, via <code>A.elements()</code> range (efficient representation)    | <strong>yes</strong>, but via indices roundtrip (inefficient)          | no, only for allocated arrays | no, not for subblocks (?) |
| Iterators                   | <strong>yes</strong>, standard compliant, random-access-iterator             | no                                                        | <strong>yes</strong>, limited | no |
| Multidimensional iterators (cursors) | <strong>yes</strong> (experimental)                                 | no                                                        | no               | no |         
| STL algorithms or Ranges    | <strong>yes</strong>                                                         | no, limited via <code>std::cartesian_product</code>                  | <strong>yes</strong>, some do not work | no |
| Compatibility with Boost    | <strong>yes</strong>, serialization, interprocess  (see below)               | no                                                        | no | no |
| Compatibility with Thrust or GPUs | <strong>yes</strong>, via flatten views (loop fusion), thrust-pointers/-refs | no                                                  | no          | no |
| Used in production          | [QMCPACK](<a href="https://qmcpack.org/" class="bare">https://qmcpack.org/</a>), [INQ](<a href="https://gitlab.com/npneq/inq" class="bare">https://gitlab.com/npneq/inq</a>)  | (?) , experience from Kokkos incarnation            | <strong>yes</strong> (?) | [<strong>yes</strong>](<a href="https://eigen.tuxfamily.org/index.php?title=Main_Page#Projects_using_Eigen" class="bare">https://eigen.tuxfamily.org/index.php?title=Main_Page#Projects_using_Eigen</a>) |</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_multi_for_fortran_programmers"><a class="link" href="#appendix_multi_for_fortran_programmers">Appendix: Multi for FORTRAN programmers</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section summarizes simple cases translated from FORTRAN syntax to C using the library.
The library strives to give a familiar feeling to those who use multidimensional arrays in FORTRAN.
Arrays can be indexed using square brackets or parenthesis, which would be more familiar to FORTRAN syntax.
The most significant differences are that array indices in FORTRAN start at `1`, and that index ranges are specified as closed intervals, while in Multi, they start by default at `0`, and ranges are half-open, following C conventions.
Like in FORTRAN, arrays are not initialized automatically for simple types (e.g., numeric); such initialization needs to be explicit.</p>
</div>
<div class="paragraph">
<p>|                             | FORTRAN                                          | C++ Multi                                            |
|---                          | ---                                              | ---                                                  |
| Declaration/Construction 1D | <code>real, dimension(2) :: numbers</code> (at top)         | <code>multi::array&lt;double, 1&gt; numbers(2);</code> (at scope)     |
| Initialization (2 elements) | <code>real, dimension(2) :: numbers = [ 1.0, 2.0 ]</code>   | <code>multi::array&lt;double, 1&gt; numbers = { 1.0, 2.0 };</code>    |
| Element assignment          | <code>numbers(2) = 99.0</code>                              | <code>numbers(1) = 99.0;</code> (or <code>numbers[1]</code>)               |
| Element access (print 2nd)  | <code>Print *, numbers(2)</code>                            | <code>std::cout &lt;&lt; numbers(1) &lt;&lt; '\n';</code>                   |
| Initialization              | <code>DATA numbers / 10.0 20.0 /</code>                     | <code>numbers = {10.0, 20.0};</code>                            |</p>
</div>
<div class="paragraph">
<p>In the more general case for the dimensionality, we have the following correspondance:</p>
</div>
<div class="paragraph">
<p>|                              | FORTRAN                                          | C++ Multi                                            |
|---                           | ---                                              | ---                                                  |
| Construction 2D (3 by 3)     | <code>real*8 :: A2D(3,3)</code> (at top)                    | <code>multi::array&lt;double, 2&gt; A2D({3, 3});</code> (at scope)    |
| Construction 2D (2 by 2)     | <code>real*8 :: B2D(2,2)</code> (at top)                    | <code>multi::array&lt;double, 2&gt; B2D({2, 2});</code> (at scope)    |
| Construction 1D (3 elements) | <code>real*8 :: v1D(3)</code>   (at top)                    | <code>multi::array&lt;double, 2&gt; v1D({3});</code> (at scope)       |
| Assign the 1st column of A2D | <code>v1D(:) = A2D(:,1)</code>                              | <code>v1( _ ) = A2D( _ , 0 );</code>                            | 
| Assign the 1st row of A2D    | <code>v1D(:) = A2D(1,:)</code>                              | <code>v1( _ ) = A2D( 0 , _ );</code>                            |
| Assign upper part of A2D     | <code>B2D(:,:) = A2D(1:2,1:2)</code>                        | <code>B2D( <em>::</em> , _ ) = A2D({0, 2}, {0, 2});</code>                |</p>
</div>
<div class="paragraph">
<p>Note that these correspondences are notationally logical;
internal representation (memory ordering) can still be different, affecting operations that interpret 2D arrays as contiguous elements in memory.</p>
</div>
<div class="paragraph">
<p>Range notation such as <code>1:2</code> is replaced by <code>{0, 2}</code>, which considers both the difference in the start index and the half-open interval notation in the C++ conventions.
Stride notation such as <code>1:10:2</code> (i.e., from first to tenth included, every two elements) is replaced by <code>{0, 10, 2}</code>.
Complete range interval (single <code>:</code> notation) is replaced by <code>multi::_</code>, which can be used simply as <code><em></code> after the declaration <code>using multi::</em>;</code>.
These rules extend to higher dimensionality.</p>
</div>
<div class="paragraph">
<p>Unlike FORTRAN, Multi doesn&#8217;t provide algebraic operators, using algorithms is encouraged instead.
For example, a FORTRAN statement like <code>A = A + B</code> is translated as this in the one-dimensional case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">{});</span>  <span class="c1">// valid for 1D arrays only</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the general dimensionality case we can write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span><span class="o">&amp;&amp;</span>      <span class="n">Aelems</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">();</span>
<span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Belems</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">elements</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">Aelems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">elems</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">Belems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Aelems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">{});</span>  <span class="c1">// valid for arbitrary dimension</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">(),</span> <span class="n">B</span><span class="p">.</span><span class="n">elements</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">{});</span>  <span class="c1">// alternative using C++20 ranges</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A FORTRAN statement like <code>C = 2.0*C</code> is rewritten as <code>std::ranges::transform(C.elements(), C.elements().begin(), [](auto const&amp; e) { return 2.0*e; });</code>.</p>
</div>
<div class="paragraph">
<p>It is possible to use C++ operator overloading for functions such as <code>operartor+=</code> (<code>A += B;</code>) or <code>operator*=</code> (<code>C *= 2.0;</code>);
however, this possibility can become unwindenly complicated beyond simple cases (also it can become inefficient if implemented naively).</p>
</div>
<div class="paragraph">
<p>Simple loops can be mapped as well, taking into account indexing differences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="fortran"><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w">         </span><span class="c1">! for(int i = 0; i != 5; ++i) {</span><span class="w">
  </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w">       </span><span class="c1">!   for(int j = 0; j != 5; ++j) {</span><span class="w">
    </span><span class="n">D2D</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="c1">!     D2D(i, j) = 0;</span><span class="w">
  </span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">            </span><span class="c1">!   }</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">              </span><span class="c1">! }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>[(live)](<a href="https://godbolt.org/z/77onne46W" class="bare">https://godbolt.org/z/77onne46W</a>)</p>
</div>
<div class="paragraph">
<p>However, algorithms like <code>transform</code>, <code>reduce</code>, <code>transform_reduce`and `for_each</code>, and offer a higher degree of control over operations, including memory allocations if needed, and even enable parallelization, providing a higher level of flexibility.
In this case, <code>std::fill(D2D.elements().begin(), D2D.elements().end(), 0);</code> will do.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Thanks</strong> to JoaquÃ­n LÃ³pez MuÃ±oz and Andrzej Krzemienski for the critical reading of the documentation and to Matt Borland for his help integrating Boost practices in the testing code.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>